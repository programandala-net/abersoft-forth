.( dis )

  \ dis.fsb

\ Self-disassembly tool for ZX Spectrum Abersoft Forth

\ Copyright (C) 2015 Marcos Cruz (programandala.net)

  \ Copying and distribution of this file, with or without
  \ modification, are permitted in any medium without royalty
  \ provided the copyright notice and this notice are
  \ preserved.  This file is offered as-is, without any
  \ warranty.

  \ -----------------------------------------------------------
  \ Description

  \ This tool prints out a partial decoding of the Forth
  \ dictionary, in Z80 assembler format.  Code written in Z80
  \ is not included, but zone definitions for the z80dasm
  \ disassembler are included as comments.
  \
  \ The printout, processed by other tools and combined with
  \ other files (see <README.adoc> and <Makefile>), is used to
  \ recreate the original Z80 source of Abersoft Forth.

  \ -----------------------------------------------------------
  \ Requirements

  /disc 16384 = 0= ?needs 16kramdisks
  needs +caseins caseins   needs /string strings
  needs save-string csb    needs s+ s-plus
  needs ?exit qexit

  \ -----------------------------------------------------------
  \ History

  \ 2015-05-20: Start, based on the Afera module `DECODE`.
  \
  \ 2015-05-21: Word header, first pfa listings.
  \
  \ 2015-05-22: First complete disassembling of all high-level
  \ words, using `editor dis-all`.
  \
  \ 2015-05-23: New: z80dasm zones are created as Z80 comments
  \ in the printout; they have to be extracted later. New:
  \ words created by `2constant` and `2variable` are
  \ recognized.
  \
  \ 2015-05-24: Little fixes. Improvement: Only the words of
  \ the original system are printed out.

  \ -----------------------------------------------------------

forth definitions 

vocabulary dis-voc  dis-voc definitions  hex

02 10 thru cls greeting cr
\  <------------------------------>
." Type 'dis' to print out a Z80" cr
." source of the FORTH and EDITOR" cr
." vocabularies." cr quit

( Base printing )

: address  ( a -- )  cr u.  ;

: margin  ( -- )  05 base @ 0A = + spaces  ;

  \ XXX OLD not used
  \ : id.bs  ( nfa -- )
  \   \ Version of id. without the final space.
  \   \ This trick is used instead of printing a backspace,
  \   \ to make sure it works on the printer.
  \   [ ' noop  cfa ] literal 6B72 !  id.
  \   [ ' space cfa ] literal 6B72 !  ;

: bhex.  ( n -- )
  base @ hex swap s->d <# # # #> ." 0x" type base !  ;
: nhex.  ( n -- )
  base @ hex swap s->d <# # # # # #> ." 0x" type base !  ;

( id )

0 constant addr  \ used as local variable

: editor-prefix  ( ca len -- ca' len' )
  \ Add the "editor_" prefix to it to the given string.
  s" editor_" 2swap s+  ;

: editor-id  ( ca len --  ca len ff | ca' len' tf )
  \ If the given string is "R" or "I",
  \ add the "editor_" prefix to it and leave a true flag,
  \ else return the string untouched and a false flag.
  2dup s" R" str= if  editor-prefix true exit  then
  2dup s" I" str= if  editor-prefix true exit  then  false  ;

: special-id  ( nfa ca len -- ca len | ca' len' )
  \ Manage special id cases.
  rot dup ' addr !  7900 > if  editor-id ?exit  then
  addr 6923 = if  2drop s" onezeroword" exit  then
  addr 6CF6 = if  2drop s" onespaceword" then  ;

: id  ( nfa -- ca len )
  \ Return the name of a word.
  \ The "editor_" prefix is added to the words
  \ `R` and `I` of the editor vocabulary.
  dup dup 1+ swap c@ 3F and save-string
  2dup + 1- dup c@ 7F and swap c!  special-id  ;

( Labels and opcodes )

0 variable current-nfa  0 variable previous-nfa

: def  ( -- )  ." : " ;

: nfa-label$  ( nfa -- ca len )  id s" _nfa" s+  ;
: lfa-label$  ( pfa -- ca len )  nfa id s" _lfa" s+  ;
: cfa-label$  ( cfa -- ca len )  2+ nfa id s" _cfa" s+  ;
: pfa-label$  ( pfa -- ca len )  nfa id s" _pfa" s+  ;

: nfa-label  ( nfa -- )  nfa-label$ type  ;
: lfa-label  ( pfa -- )  lfa-label$ type  ;
: cfa-label  ( cfa -- )  cfa-label$ type  ;
: pfa-label  ( pfa -- )  pfa-label$ type  ;

: defw  ( -- )  ." defw "  ;  : defb  ( -- )  ." defb "  ;

( z80dasm zones )

0 variable zone-first
0 variable zone-last

: z80dasm-zone  ( ca len -- )
  \ ca len = label
  cr ." ; [Z80DASM ZONE] " type ." : first " zone-first @ nhex.
  ."  last " zone-last @ nhex. ."  type " ;

: bytedata-zone  ( ca len -- )  z80dasm-zone ." bytedata"  ;
: worddata-zone  ( ca len -- )  z80dasm-zone ." worddata"  ;
: pointers-zone  ( ca len -- )  z80dasm-zone ." pointers"  ;
: code-zone  ( ca len -- )  z80dasm-zone ." code"  ;

: (dis-code)  ( pfa pfa+n -- )
  \ Print the z80dasm code zone of a low-level word
  \ or the `;code` part of a high-level word.
  zone-first !  previous-nfa @ 1- zone-last !
  pfa-label$ code-zone  ;

: dis-code  ( pfa -- )
  \ Print the z80dasm code zone of a low-level word.
  dup (dis-code)  ;

( Special cases )

: dis-compile  ( pfa+n -- pfa+n+2 )
  2+ dup @ ." , " cfa-label  ;

: dis-literal  ( pfa+n -- pfa+n+2 )  2+ dup @ ." , " nhex.  ;

: dis-branch  ( pfa+n -- pfa+n+2 )
  \ XXX TODO Create destination label, that will
  \ be put in place when the source is sorted.
  dis-literal  ."  ; to " dup dup @ + nhex.  ;

: (dis-string)  ( ca len -- )
  dup bhex. [char] , emit [char] " emit type [char] " emit  ;

: dis-string  ( pfa+n1 -- pfa+n1+n2 )
  2+ dup address defb dup count (dis-string) dup c@ + 1-  ;

( Special cases dispatcher )

: dis-special-cases  ( pfa+n1 -- pfa+n1 | pfa+n2 )
  dup @ case
          [ ' compile cfa ] literal of  dis-compile  endof
          [ ' lit     cfa ] literal of  dis-literal  endof
          [ ' branch  cfa ] literal of  dis-branch   endof
          [ ' 0branch cfa ] literal of  dis-branch   endof
          [ ' (loop)  cfa ] literal of  dis-branch   endof
          [ ' (+loop) cfa ] literal of  dis-branch   endof
          [ ' (.")    cfa ] literal of  dis-string   endof
          [ ' slit    cfa ] literal of  dis-string   endof
        endcase  ;

( Checks )

  \ Did the colon word finished with `;code`?
false variable semicolon-code?

: colon-end?  ( a -- f )
  \ Is the given address the end of a colon definition?
  ' addr !  semicolon-code? off  true
  addr @ [ ' ;s cfa ] literal = ?exit
  addr @ [ ' (;code) cfa ] literal  = 
    dup semicolon-code? !  ?exit
  addr 6E04 = ?exit  \ end of COLD
  addr 6DAE = ?exit  \ end of WARM
  addr 6D6A = ?exit  \ end of ABORT
  addr 6C99 = ?exit  \ end of INTERPRET
  addr 6B2A = ?exit  \ end of ERROR
  addr 6D4C = ?exit  \ end of QUIT
  0= ;

( Word type checks, user variables )

: colon?      ( pfa -- f )  cfa @ ' : cfa @ =  ;
: constant?   ( pfa -- f )  cfa @ 6348 =  ;
: variable?   ( pfa -- f )  cfa @ 6362 =  ;
: user?       ( pfa -- f )  cfa @ 6374 =  ;
: 2constant?  ( pfa -- f )  cfa @ 7F00 =  ;
: 2variable?  ( pfa -- f )  cfa @ 7F23 =  ;
: code?       ( pfa -- f )  dup cfa @ =  ;

: dis-user  ( pfa --- )
  \ Print a user variable.
  dup dup zone-last !  dup address defw @ nhex.
  pfa-label$ bytedata-zone ;

( Constants, variables, colon definitions )

: dis-value  ( pfa --- )
  \ Print a value (constant or variable).
  dup dup 1+ zone-last !  dup address defw @ nhex.
  pfa-label$ worddata-zone ;

: dis-2value  ( pfa --- )
  \ Print a double value (constant or variable).
  dup dup 3 + zone-last !
  dup address defw dup @ nhex. ." , " 2+ @ nhex.
  pfa-label$ worddata-zone ;

: dis-colon  ( pfa --- )
  \ Print a colon definition.
  dup dup begin   dup address  dup colon-end? 0=
          while   defw  dup @ cfa-label dis-special-cases 2+
          repeat  dup defw @ cfa-label
  1+ zone-last ! pfa-label$  pointers-zone  ( pfa )
  \ If the word was finished by `;code`, define a code zone
  \ for z80dasm.
  semicolon-code? @ if    zone-last @ 1 + (dis-code)
                    else  drop  then  ;

( Name field )

: (name)  ( ca len -- )
  \ Print the main part of the name of the name field.
  [char] " emit 2dup 1 /string type [char] " emit
  [char] , emit  ;

: name  ( ca len -- )
  \ Print the name of the name field,
  \ with the final letter apart with its bit 7 set.
  dup 1 > if  (name)  then
  [char] " emit + c@ 7F and emit [char] " emit ." +0x80"  ;

: len-only  ( b1 -- b2 )  3F and  ;

: count-byte  ( b -- )
  \ Print the count byte of the name field,
  \ showing the bound and precedence bits apart.
  dup len-only bhex. ." +0x80" 40 and if  ." +0x40"  then  ;

( Name and link fields )

: name-field  ( pfa -- )
  \ Print the name field.
  nfa dup dup zone-first !
      current-nfa @ previous-nfa ! dup current-nfa !
      dup address dup space nfa-label def
      dup address defb dup c@ count-byte
      dup c@ len-only ." , " 2dup + zone-last !  name
      nfa-label$ bytedata-zone ;

: link-field  ( pfa -- )
  \ Print the link field.
  dup dup dup lfa dup zone-first ! address space lfa-label def
  lfa dup address defw @ dup if  nfa-label  else  u.  then
  zone-first @ 1+ zone-last ! lfa-label$ pointers-zone ;

( Code field, parameter field, header )

: (code-field) ( pfa -- )
  \ Print the content of the code field.
  dup cfa @ 2dup =
  if  drop pfa-label else  nhex. drop  then  ;

: code-field  ( pfa -- )
  \ Print the code field.
  dup cfa dup zone-first ! dup address space cfa-label def
  dup cfa address defw dup (code-field)
  cfa cfa-label$ zone-first @ 1+ zone-last ! pointers-zone  ;

: parameter-field  ( pfa -- )
  \ Print the parameter field.
  dup zone-first !  dup address space pfa-label def  ;

: header  ( pfa -- )
  \ Print the header of a definition.
  dup name-field  dup link-field
  dup code-field  parameter-field  ;

( Partial dis )

: (dis-pfa)  ( pfa --- )
  \ Print a word.
  dup header  dup colon?     if  dis-colon  exit  then
              dup code?      if  dis-code   exit  then
              dup constant?  if  dis-value  exit  then
              dup variable?  if  dis-value  exit  then
              dup 2constant? if  dis-2value exit  then
              dup 2variable? if  dis-2value exit  then
              dup user?      if  dis-user  exit  then
  drop ." ; XXX This word can not be disassembled by dis."  ;

  \ Print a word, if it belongs to the original system.
: dis-pfa  ( pfa -- )  dup [ ' udg 1+ ] literal u<
                       if  (dis-pfa)  else  drop  then  ;

: dis-from-nfa  ( nfa -- )
  \ Print starting from a word.
  begin  pfa dup dis-pfa  lfa @ dup 0= ?terminal or
  until  drop  ;

  \ Print the context vocabulary,
  \ and the vocabularies it's chained to.
: dis-context  ( -- )  context @ @  dis-from-nfa  ;

( Main dis )

: dis  ( -- )
  \ Print out all original words of the Forth system.
  hex  1 link
  editor dis-context
  0 link  decimal cr ." Done." cr  ;

  \ vim: filetype=abersoftforthafera
