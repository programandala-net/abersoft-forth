;  TITLE < Z80 fig-FORTH 1.1 g >
;  SUBTTL  Adaptive version by EHR
;
;
; Modified frm FIG document keyed by Dennis L. Wilson 800907
; Converted frm "8080 FIG-FORTH VERSION A0 15SEP79"
;
; fig-FORTH release 1.1 for the 8080 processor.
;
; ALL PUBLICATIONS OF THE FORTH INTEREST GROUP
; ARE PUBLIC DOMAIN. THEY MAY BE FURTHER
; DISTRIBUTED BY THE INCLUSION OF THIS CREDIT NOTICE:
;
; This publication has been made available by the
; Forth Interest Group
; P.O.Box 1105
; San Carlos, CA 94070
; U.S.A.
;
; Implementation on 8080 by:
; John Cassady
; 339 15th Street
; Oakland, CA 94612
; U.S.A
; on 790528
; Modified by:
; Kim Harris
; Acknowledgements:
; George Flammer
; Robt. D. Villwock
; ----------------------------------------------------------------------
; Z80 Version for Cromemco CDOS & Digital Research CP/M by:
; Dennis Lee Wilson c/o
; Aristotelian Logicians
; 2631 East Pinchot Avenue
; Phoenix, AZ 85016
; U.S.A.
; ----------------------------------------------------------------------
; The 2 byte Z80 code for Jump Relative (JR) has been substituted for
; the 3 byte Jump (JP) wherever practical. The port I/O words P@ & P!
; have been made ROMable by use of Z80 instructions.
; ----------------------------------------------------------------------
; Further modifications (marked ;/) by:
; Edmund Ramm
; Anderheitsallee 24
; 2000 Hamburg 71
; Fed. Rep. of Germany  840418
; ----------------------------------------------------------------------
; Disc I/O has been modified a la Albert van der Horst (HCCH) to employ
; CP/M 2.x's random access feature.
; ----------------------------------------------------------------------

; Changes by Marcos Cruz (programandala.net):

; 2015-05-13: Start editing to compile with Pasmo.
;
; 2015-05-20: Lower case. Draft of header macro. IX and IY are freed. Some
; little changes.


; Release & Version numbers
;
figrel  equ 1   ;fig release #
figrev  equ 1   ;fig revision #
usrver  equ 0x67   ;user version # g by dlw/ehr/AvdH


;Console & printer drivers are in external source named
;CONPRTIO.FTH & disc drivers in DISCIO.FTH. It has 4 screen
;buffers & end of memory is set to fbase from locn. 0007H.
; ascii characters used
;
abl equ 0x20   ;blank
acr equ 0x0D   ;cr
adot  equ 0x2E   ;.
bell  equ 0x07   ;^g
bsin  equ 0x08   ;backspace chr = ^h
bsout equ 0x08
dle equ 0x10   ;^p
lf  equ 0x0A   ;^j
ff  equ 0x0C   ;^l
;
; Memory allocation
;
bdoss   equ 0x0005   ;/ system entry
nscr    equ 4   ;  # of 1024 byte screens
kbbuf   equ 128   ;  bytes/disc buffer
us      equ 0x40   ;  user variables space
rts     equ 0x400    ;  Return Stack & term buff space
co      equ kbbuf+4   ;  Disc buff + 2 header + 2 tail
nbuf    equ nscr*0x400/kbbuf ;  # of buffers
bufsiz  equ co*nbuf   ;/ total disc buffer size

  abs
;
  org 0x0100
origin:
  nop
  jp cld   ;vector to cold start
  nop
  jp wrm   ;vector to warm start
  defb figrel    ;fig release #
  defb figrev    ;fig revision #
  defb usrver    ;user version #
  defb 0x0E   ;implementation attributes
;
;
;
; 0x0E = 0000:1110
;       ---------
; b +origin   ...W:ieba
;
; w: 0=above sufficient
;    1=other differences exist
; i: Interpreter is 0=pre-
;     1=post incrementing
; e: Addr must be even: 0 yes
;     1 no
; b: High byte @  0=low addr.
;     1=high addr.
; a: cpu Addr.    0=byte
;     1=word
;
;
;
  defw task-7    ;  topmost word in forth vocabulary
  defw bsin    ;  backspace chr
upinit:
  defw 0   ;/ init (up)
;
; * following used by cold; must be in same order as user variables *
;
s0init:
  defw 0   ;/ init (s0)
r0init:
  defw 0   ;/ init (r0)
tibini:
  defw 0   ;/ init (tib)
  defw 0x1F   ;  init (width)
  defw 0   ;  init (warning)
  defw initdp    ;  init (fence)
  defw initdp    ;  init (dp)
  defw forth+8   ;  init (voc-link)
;
; *  end data used by cold *
;
  defw 0H,0B250H ;z80 cpu name (hw,lw)
        ;(32 bit base 36 integer)

; registers
;
; Forth  Z80  Forth preservation rules
; -----  ---  -----------------------
; IP     bc   Should be preserved accross forth words.
; W      de   Sometimes output from next, may be altered b4 JP'ing to next,
;             input only when "dpush" called.
; SP     sp   Should be used only as data stack accross forth words,
;             may be used within forth words if restored before "next".
;        hl   Never output from next, input only when "hpush" called


up:
  defw 0   ;/ user area ptr
rpp:
   defw  0   ;/ return stack ptr
buf1:
  defw 0   ;/ address of 1st disc buffer
;
;
; comment conventions:
;
; = means "is equal to"
; <-- means assignment
; name  =     addr of name
; (name)  =     contents @ name
; ((name))=     indirect contents
; cfa =     code field addr
; lfa =     link field addr
; nfa =     name field addr
; pfa =     parameter field addr
; s1  =     addr of 1st word of parameter stack
; s2  =     -"-  of 2nd -"-  of    -"-     -"-
; r1  =     -"-  of 1st -"-  of return stack
; r2  =     -"-  of 2nd -"-  of  -"-    -"-
; ( above Stack posn. valid b4 & after execution of any word, not during)
;
; lsb =     least significant bit
; msb =     most  significant bit
; lb  =     low  byte
; hb  =     high byte
; lw  =     low  word
; hw  =     high word
; (May be used as suffix to above names)

; forth address interpreter
; post incrementing version
;
dpush:
   push  de
hpush:
   push  hl    ;   iy points here
next:
  ld a,(bc)    ;(w)<--((ip)) ix points here
  ld l,a
  inc bc    ;inc ip
  ld a,(bc)
  ld h,a   ;(hl)<--cfa
  inc bc    ;inc ip
next1:
  ld e,(hl)    ;(pc)<--((w))
  inc hl
  ld d,(hl)
  ex de,hl
  jp (hl)    ;note: (de)=cfa+1
;

; forth dictionary
; dictionary format:
;
;       byte
; address name    contents
; ------- ----    --------
;           (msb=1
;           (p=precedence bit
;           (s=smudge bit
; nfa name field  1PS<len>  <name length
;       0<1CHAR>  msb=0, NAME'S 1st char
;       0<2CHAR>
;         ...
;       1<lchar>  msb=1, NAME'S last char
; lfa link field  <linklb>  =previous WORD'S nfa
;       <linkhb>
;label: cfa code field  <codelb>  =addr cpu code
;       <codehb>
; pfa parameter <1PARAM>  1st parameter byte
;   field   <2PARAM>
;         ...
;

  ; XXX TODO adapt this macro from DZX-Forth

_header: macro name,immediate,alias_xt

  ; name        = name string
  ; immediate   = _immediate or nothing
  ; alias_xt    = alias xt

  ; the name field
  last_nfa: defl $ ; link address for next word
  bits: defl 0
  if not nul immediate
    ; set immediate bit
    bits: defl bits | immediate_mask
  endif
  if not nul alias_xt
    ; set alias bit
    bits: defl bits | alias_mask
  endif
  local _first ; address of the first char of the name
  local _next  ; address after the last char of the name
  db _next-_first+bits    ; count and flags byte
  _first: db name
  _next:

  ; the link field
  dw previous_nfa

  ; the code field
  if nul alias_xt
    last_xt: defl $+2
  else
    last_xt: defl alias_xt
  endif
  dw last_xt
  previous_nfa: defl last_nfa

endm

dp0:
  defb 0x83   ;lit
  defm 'LIT'
  defw 0   ;(lfa)=0 marks end of dictionary
lit:
  defw $+2   ;(s1)<--((ip))
  ld a,(bc)    ;(hl)<--((ip))=literal
  inc bc    ;(ip)<--(ip)+2
  ld l,a   ;lb
  ld a,(bc)    ;hb
  inc bc
  ld h,a
  jp hpush      ;(s1)<--(hl)
;
  defb 0x87   ;execute
  defm 'EXECUTE'
  defw lit-6
exec:
  defw $+2
  pop hl
  jp next1
;
  defb 0x86   ;branch
  defm 'BRANCH'
  defw exec-0x0A
bran:
  defw $+2   ;(ip)<--(ip)+((ip))
bran1:
  ld h,b   ;(hl)<--(ip)
  ld l,c
  ld e,(hl)    ;(de)<--((ip))=branch offset
  inc hl
  ld d,(hl)
  dec hl
  add hl,de   ;(hl)<--(hl)+((ip))
  ld c,l   ;(ip)<--(hl)
  ld b,h
  jp next
;
  defb 0x87   ;0BRANCH
  defm '0BRANCH'
  defw bran-9
zbran:
  defw $+2
  pop hl
  ld a,l
  or h
  jr z,bran1   ;if (s1)=0 then branch
  inc bc    ;else skip branch offset
  inc bc
  jp next
;
  defb 0x86   ;(loop)
  defm '(loop)'
  defw zbran-0x0A
xloop:
  defw $+2
  ld hl,(rpp)  ;  ((hl))=index=(r1)
  inc (hl)    ;/  index(lb) += 1
  ld e,(hl)    ;/
  inc hl    ;/ (hl)-->index(hb)
  jr nz,xloop1 ;/ jump if ((hl)) < 256
  inc (hl)    ;/ else index(hb) += 1
xloop1: ld  d,(hl)    ;/ (de)<-- new index
  inc hl    ;/ ((hl))=limit
  ld a,e
  sub (hl)
  ld a,d
  inc hl
  sbc a,(hl)    ;  index<limit?
  jp m,bran1   ;  yes, loop again
  inc hl    ;  no, done
  ld (rpp),hl  ;  discard r1 & r2
  inc bc
  inc bc    ;  skip branch offset
  jp next
;
  defb 0x87   ;(+loop)
  defm '(+loop)'
  defw xloop-9
xploo:
  defw $+2
  pop de    ;(de)<--incr
  ld hl,(rpp)  ;((hl))=index
  ld a,(hl)    ;index<--index+incr
  add a,e
  ld (hl),a
  ld e,a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a
  inc hl    ;((hl))=limit
  inc d
  dec d
  ld d,a   ;(de)<--new index
  jp m,xloo2   ;if incr>0
  ld a,e
  sub (hl)    ;then (a)<--index - limit
  ld a,d
  inc hl
  sbc a,(hl)
  jp xloo3
xloo2:
  ld a,(hl)    ;else (a)<--limit - index
  sub e
  inc hl
  ld a,(hl)
  sbc a,d
;       ;if (a)<0
xloo3:
  jp m,bran1   ;then loop agn
  inc hl    ;else done
  ld (rpp),hl  ;discard r1 & r2
  inc bc    ;skip branch offset
  inc bc
  jp next
;
  defb 0x84   ;  (do)
  defm '(do)'
  defw xploo-0x0A
xdo:
  defw $+2
  exx ;/ save ip
  pop de    ;  (de)<--initial index
  pop bc    ;/ (bc)<--limit
  ld hl,(rpp)  ;  (hl)<--(rp)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c    ;/ (r2)<--limit
  dec hl
  ld (hl),d
  dec hl
  ld (hl),e    ;  (r1)<--initial index
  ld (rpp),hl  ;  (rp)<--(rp)-4
  exx ;/ restore ip
  jp next
;
  defb 0x81   ;i
  defm 'I'
  defw xdo-7
ido:
  defw $+2   ;(s1)<--(r1), (r1) unchanged
  ld hl,(rpp)
  ld e,(hl)    ;(de)<--(r1)
  inc hl
  ld d,(hl)
  push de    ;(s1)<--(de)
  jp next
;
  defb 0x85   ;digit
  defm 'DIGIT'
  defw ido-4
digit:
  defw $+2
  pop hl    ;(l)<--(s1)lb = base value
  pop de    ;(e)<--(s2)lb = ascii chr to be converted
  ld a,e   ;accu<--chr
  sub '0'   ;>=0?
  jr c,digi2   ;/ <0 is invalid
  cp 0x0A   ;>9?
  jr c,digi1   ;/ no, test base value
  sub 0x07   ;gap between "9" & "a", nw "a"=0x0A
  cp 0x0A   ;>="a"?
  jr c,digi2   ;/ CHRs between "9" & "a" are invalid
digi1:
  cp l   ;<base value?
  jr nc,digi2  ;/ no, invalid
  ld e,a   ;(s2)<--(de) = converted digit
  ld hl,0x0001  ;(s1)<--true
  jp dpush
digi2:
  ld l,h   ;(hl)<--false
  jp hpush      ;(s1)<--false
;
  defb 0x86   ;(find) (2-1)failure
  defm '(find)'  ; (2-3)success
  defw digit-8
pfind:
  defw $+2
  pop de    ;(de)<--nfa
pfin1:
  pop hl    ;(hl)<--string addr
  push hl    ;save for next iteration
  ld a,(de)
  xor (hl)    ;filter deviations
  and 0x3F   ;mask msb & precedence bit
  jr nz,pfin4  ;lengths differ
pfin2:
  inc hl    ;(hl)<--addr next chr in string
  inc de    ;(de)<--addr next chr in nf
  ld a,(de)
  xor (hl)    ;filter deviations
  add a,a
  jr nz,pfin3  ;no match
  jr nc,pfin2  ;match so far, loop agn
  ld hl,0x0005  ;string matches
  add hl,de   ;((sp))<--pfa
  ex (sp),hl
pfin6:
  dec de    ;posn de on nfa
  ld a,(de)
  or a   ;msb=1? =length byte
  jp p,pfin6   ;no, try next chr
  ld e,a   ;(e)<--length byte
  ld d,0x00
  ld hl,0x0001  ;(hl)<--true
  jp dpush   ;nf found, return
;
;above nf not a match, try next one
;
pfin3:
  jr c,pfin5   ;carry=end of nf
pfin4:
  inc de    ;find end of nf
  ld a,(de)
  or a   ;msb=1?
  jp p,pfin4   ;no, loop
pfin5:
  inc de    ;(de)<--lfa
  ex de,hl
  ld e,(hl)
  inc hl
  ld d,(hl)    ;(de)<--(lfa)
  ld a,d
  or e   ;end of dictionary? (lfa)=0
  jr nz,pfin1  ;no, try previous definition
  pop hl    ;drop string addr
  ld hl,0    ;(hl)<--false
  jp hpush      ;no match found, return
;
  defb 0x87   ;enclose
  defm 'ENCLOSE'
  defw pfind-9
encl:
  defw $+2
  pop de    ;(de)<--(s1)=delimiter chr
  pop hl    ;(hl)<--(s2)=addr of text to scan
  push hl    ;(s4)<--addr
  ld a,e
  ld d,a   ;(d)<--delim chr
  ld e,-1    ;init chr offset counter
  dec hl    ;(hl)<--addr-1
encl1:
  inc hl    ;skip over leading delim CHRs
  inc e
  cp (hl)    ;delim chr?
  jr z,encl1   ;yes, loop
  ld d,0
  push de    ;(s3)<--(e)=offset to 1st non delim
  ld d,a   ;(d)<--delim chr
  ld a,(hl)
  and a   ;1st non-delim=null?
  jr nz,encl2  ;no
  ld d,0   ;yes
  inc e
  push de    ;(s2)<--offset to byte following null
  dec e
  push de    ;(s1)<--offset to null
  jp next
encl2:
  ld a,d   ;(a)<--delim chr
  inc hl    ;(hl)<--addr next chr
  inc e   ;(e)<--offset to next chr
  cp (hl)    ;delim chr?
  jr z,encl4   ;yes
  ld a,(hl)
  and a   ;null?
  jr nz,encl2  ;no, cont scan
encl3:
  ld d,0
  push de    ;(s2)<--offset to null
  push de    ;(s1)<--offset to null
  jp next
encl4:
  ld d,0
  push de    ;(s2)<--offset to byte following text
  inc e
  push de    ;(s1)<--offset to 2 bytes after end of word
  jp next
;
  defb 0x84   ;emit
  defm 'EMIT'
  defw encl-0x0A
emit:
  defw docol
  defw pemit
  defw one,outt
  defw pstor,semis
;
  defb 0x83   ;key
  defm 'KEY'
  defw emit-7
key:
  defw $+2
  jp pkey
;
  defb 0x89   ;?terminal
  defm '?TERMINAL'
  defw key-6
qterm:
  defw $+2
  ld hl,0
  jp pqter
;
  defb 0x82   ;cr
  defm 'CR'
  defw qterm-0x0C
cr:
  defw $+2
  jp pcr
;
  defb 0x85   ;cmove
  defm 'CMOVE'
  defw cr-5
cmove:
  defw $+2
  exx ;/ save ip
  pop bc    ;  (bc)<--(s1)= #CHRs
  pop de    ;  (de)<--(s2)= dest addr
  pop hl    ;/ (hl)<--(s3)= source addr
  ld a,b
  or c   ;  bc=0?
  jr z,excmov  ;  yes, DON'T move anything
  ldir ;/ xfer string
excmov:
  exx ;/ restore ip
  jp next
;
  defb 0x82   ;u*   16*16 unsigned multiply
  defm 'U*'    ;994 t cycles average (8080)
  defw cmove-8
ustar:
  defw $+2
  pop de    ;(de)<--mplier
  pop hl    ;(hl)<--mpcand
  push bc    ;save ip
  ld b,h
  ld a,l   ;(ba)<--mpcand
  call mpyx    ;(ahl)1<--MPCAND.LB*mplier
        ;       1st partial product
  push hl    ;save (hl)1
  ld h,a
  ld a,b
  ld b,h   ;save (a)1
  call mpyx    ;(ahl)2<--MPCAND.HB*mplier
        ; 2nd partial product
  pop de    ;(de)<--(hl)1
  ld c,d   ;(bc)<--(ah)1
; form sum of partials:
;       ; (ahl)1
;       ;+(ahl)2
;       ;-------
;       ; (ahle)
  add hl,bc   ;(hl)<--(hl)2+(ah)1
  adc a,0x00   ;(ahle)<--(ba)*(de)
  ld d,l
  ld l,h
  ld h,a   ;(hlde)<--mplier*mpcand
  pop bc    ;restore ip
  push de    ;(s2)<--PRODUCT.LW
  jp hpush      ;(s1)<--PRODUCT.HW
;
; multiply primitive
;    (ahl)<--(a)*(de)
; #bits:    24  8   16
;
mpyx:
  ld hl,0    ;(hl)<--0=partial PRODUCT.LW
  ld c,0x08   ;loop counter
mpyx1:
  add hl,hl   ;left shift (ahl) 24 bits
  rla
  jr nc,mpyx2  ;if next mplier bit = 1
  add hl,de   ;then add mpcand
  adc a,0
mpyx2:
  dec c   ;last mplier bit?
  jr nz,mpyx1  ;no, loop agn
  ret ;yes, done
;
  defb 0x82   ;u/
  defm 'U/'
  defw ustar-5
uslas:
  defw $+2
  ld hl,0x0004
  add hl,sp   ;((hl))<--NUMERATOR.LW
  ld e,(hl)    ;(de)<--NUMER.LW
  ld (hl),c    ;save ip on stack
  inc hl
  ld d,(hl)
  ld (hl),b
  pop bc    ;(bc)<--denominator
  pop hl    ;(hl)<--NUMER.HW
  ld a,l
  sub c
  ld a,h
  sbc a,b   ;numer >= denom?
  jr c,usla1   ;no, go ahead
  ld hl,0FFFFH ;yes, overflow
  ld d,h
  ld e,l   ;/ set rem & quot to max
  jp usla7
usla1:
  ld a,0x10   ;loop counter
usla2:
  add hl,hl   ;left shift (hlde) thru carry
  rla ;rot carry into accu bit 0
  ex de,hl
  add hl,hl
  jr nc,usla3
  inc de    ;add carry
  and a   ;reset carry
usla3:
  ex de,hl   ;shift done
  rra ;restore 1st carry & counter
  jr nc,usla4  ;if carry=1
  or a   ;/ reset carry
  sbc hl,bc   ;/ then (hl)<--(hl)-(bc)
  jp usla5
usla4:
  sbc hl,bc   ;/ (hl)<--partial remainder
  jr nc,usla5
  add hl,bc   ;underflow, restore
  dec de
usla5:
  inc de    ;inc quot
  dec a   ;counter=0?
  jp nz,usla2  ;no, loop agn
usla7:
  pop bc    ;restore ip
  push hl    ;(s2)<--remainder
  push de    ;(s1)<--quotient
  jp next
;
  defb 0x83   ;and
  defm 'AND'
  defw uslas-5
andd:
  defw $+2   ;(s1)<--(s1) and (s2)
  pop de
  pop hl
  ld a,e
  and l
  ld l,a
  ld a,d
  and h
  ld h,a
  jp hpush
;
  defb 0x82   ;or
  defm 'OR'
  defw andd-6
orr:
  defw $+2   ;(s1)<--(s1) or (s2)
  pop de
  pop hl
  ld a,e
  or l
  ld l,a
  ld a,d
  or h
  ld h,a
  jp hpush
;
  defb 0x83   ;xor
  defm 'XOR'
  defw orr-5
xorr:
  defw $+2   ;(s1)<--(s1) xor (s2)
  pop de
  pop hl
  ld a,e
  xor l
  ld l,a
  ld a,d
  xor h
  ld h,a
  jp hpush
;
  defb 0x83   ;sp@
  defm 'SP@'
  defw xorr-6
spat:
  defw $+2   ;(s1)<--(sp)
  ld hl,0
  add hl,sp   ;(hl)<--(sp)
  jp hpush
;
  defb 0x83   ;sp!
  defm 'SP!'
  defw spat-6
spsto:
  defw $+2   ;(sp)<--(s0) (user variable)
  ld hl,(up)   ;(hl)<--user var base addr
  ld de,0x0006
  add hl,de   ;(hl)<--s0
  ld e,(hl)
  inc hl
  ld d,(hl)    ;(de)<--(s0)
  ex de,hl
  ld sp,hl   ;(sp)<--(s0)
  jp next
;
  defb 0x83   ;rp@
  defm 'RP@'
  defw spsto-6
rpat:
  defw $+2   ;(s1)<--(rp)
  ld hl,(rpp)
  jp hpush
;
  defb 0x83   ;rp!
  defm 'RP!'
  defw rpat-6
rpsto:
  defw $+2   ;(rp)<--(r0) (user variable)
  ld hl,(up)   ;(hl)<--user var base addr
  ld de,0x0008
  add hl,de   ;(hl)<--r0
  ld e,(hl)
  inc hl
  ld d,(hl)    ;(de)<--(r0)
  ld (rpp),de  ;/ (rp)<--(r0)
  jp next
;
  defb 0x82   ; ;s
  defm ';S'
  defw rpsto-6
semis:
  defw $+2   ;(ip)<--(r1)
  ld hl,(rpp)
  ld c,(hl)
  inc hl
  ld b,(hl)    ;(bc)<--(r1)
  inc hl
  ld (rpp),hl  ;(rp)<--(rp)+2
  jp next
;
  defb 0x85   ;leave
  defm 'LEAVE'
  defw semis-5
leave:
  defw $+2   ;limit<--index
  ld hl,(rpp)
  ld e,(hl)
  inc hl
  ld d,(hl)    ;(de)<--(r1)=index
  inc hl
  ld (hl),e
  inc hl
  ld (hl),d    ;(r2)<--(de)=limit
  jp next
;
  defb 0x82   ;>r
  defm '>R'
  defw leave-8
tor:
  defw $+2
  pop de
  ld hl,(rpp)
  dec hl
  ld (hl),d    
  dec hl
  ld (hl),e    ;/ (r1)<--(de)
  ld (rpp),hl  ;  (rp)<--(rp)-2
  jp next
;
  defb 0x82   ;r>
  defm 'R>'
  defw tor-5
fromr:
  defw $+2
  ld hl,(rpp)
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld (rpp),hl
  push de    ;(s1)<--(r1)
  jp next
;
  defb 0x81   ;r
  defm 'R'
  defw fromr-5
rfetch:
  defw ido+2
;
  defb 0x82   ;0=
  defm '0='
  defw rfetch-4
zequ:
  defw $+2
  pop hl
  ld a,l
  or h
  ld hl,0
  jr nz,zequ1
  inc l   ;(hl)<--true
zequ1:
  jp hpush
;
  defb 0x82   ;0<
  defm '0<'
  defw zequ-5
zless:
  defw $+2
  pop af    ;/ (a)<--(s1)h
  rla ;/ (carry)<--bit 7
  ld hl,0    ;  (hl)<--false
  jr nc,zles1
  inc l   ;  (hl)<--true
zles1:
  jp hpush
;
  defb 0x81   ;+
  defm '+'
  defw zless-5
plus:
  defw $+2
  pop de
  pop hl
  add hl,de
  jp hpush
;
  defb 0x82   ;d+ ( d1L d1H d2L d2h -- d3L d3H)
  defm 'D+'
  defw plus-4
dplus:
  defw $+2
  exx ;/ save ip
  pop bc    ;  (bc)<--d2H
  pop hl    ;  (hl)<--d2L
  pop af    ;d (af)<--d1H
  pop de    ;  (de)<--d1L
  push af    ;/ (s1)<--d1H
  add hl,de   ;  (hl)<--d2L+d1L=d3L
  ex de,hl   ;  (de)<--d3L
  pop hl    ;  (hl)<--d1H
  adc hl,bc   ;/ (hl)<--d1H+d2H+carry=d3H
  push de    ;  (s2)<--d3L
  push hl    ;/ (s1)<--d3H
  exx ;/ restore ip
  jp next
;
  defb 0x85   ;minus
  defm 'MINUS'
  defw dplus-5
minus:
  defw $+2
  pop de    ;/
  xor a   ;/ reset carry, (a)<--0
  ld h,a   ;/
  ld l,a   ;/ ld hl,0
  sbc hl,de   ;/ (hl)<--(de)2's COMPL.
  jp hpush
;
  defb 0x86   ;dminus
  defm 'DMINUS'
  defw minus-8
dminu:
  defw $+2
  pop hl    ;(hl)<--d1H
  pop de    ;(de)<--d1L
  sub a   ;(a)<--0
  sub e
  ld e,a   ;(e)<--neg(e)
  ld a,0x00
  sbc a,d
  ld d,a   ;(d)<--neg(d)
  ld a,0x00
  sbc a,l
  ld l,a   ;(l)<--neg(l)
  ld a,0x00
  sbc a,h
  ld h,a   ;(h)<--neg(h)
  jp dpush   ;(s2)<--d2L, (s1)<--d2H
;
  defb 0x84   ;over
  defm 'OVER'
  defw dminu-9
over:
  defw $+2
  pop de
  pop hl
  push hl
  jp dpush
;
  defb 0x84   ;drop
  defm 'DROP'
  defw over-7
drop:
  defw $+2
  pop hl
  jp next
;
  defb 0x84   ;swap
  defm 'SWAP'
  defw drop-7
swap:
  defw $+2
  pop hl
  ex (sp),hl
  jp hpush
;
  defb 0x83   ;dup
  defm 'DUP'
  defw swap-7
dup:
  defw $+2
  pop hl
  push hl
  jp hpush
;
  defb 0x84   ;2DUP
  defm '2DUP'
  defw dup-6
tdup:
  defw $+2
  pop hl
  pop de
  push de
  push hl
  jp dpush
;
  defb 0x82   ;+!
  defm '+!'
  defw tdup-7
pstor:
  defw $+2
  pop hl    ;(hl)<--var addr
  pop de    ;(de)<--number
  ld a,(hl)
  add a,e
  ld (hl),a
  inc hl
  ld a,(hl)
  adc a,d
  ld (hl),a    ;((hl))<--((hl))+number
  jp next
;
  defb 0x86   ;toggle
  defm 'TOGGLE'
  defw pstor-5
toggl:
  defw $+2
  pop de    ;(e)<--bit pattern
  pop hl    ;(hl)<--addr
  ld a,(hl)
  xor e
  ld (hl),a
  jp next
;
  defb 0x81   ;@
  defm '@'
  defw toggl-9
at:
  defw $+2
  pop hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp next
;
  defb 0x82   ;c@
  defm 'C@'
  defw at-4
cat:
  defw $+2
  pop hl
  ld l,(hl)
  ld h,0
  jp hpush
;
  defb 0x82   ;2@
  defm '2@'
  defw cat-5
tat:
  defw $+2
  exx ;/ save ip
  pop hl    ;  (hl)<--addr
  ld c,(hl)
  inc hl
  ld b,(hl)    ;/ (bc)<--dH
  inc hl
  ld e,(hl)
  inc hl
  ld d,(hl)    ;  (de)<--dL
  push de    ;  (s2)<--dL
  push bc    ;/ (s1)<--dH
  exx ;/ restore ip
  jp next
;
  defb 0x81   ;!
  defm '!'
  defw tat-5
store:
  defw $+2
  pop hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  jp next
;
  defb 0x82   ;c!
  defm 'C!'
  defw store-4
cstor:
  defw $+2
  pop hl
  pop de
  ld (hl),e
  jp next
;
  defb 0x82   ;2!
  defm '2!'
  defw cstor-5
tstor:
  defw $+2
  pop hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  inc hl
  pop de
  ld (hl),e
  inc hl
  ld (hl),d
  jp next
;
  defb 0xC1    ; :
  defm ':'
  defw tstor-5
colon:
  defw docol
  defw qexec
  defw scsp
  defw curr
  defw at
  defw cont
  defw store
  defw creat
  defw rbrac
  defw pscod
docol:
  ld hl,(rpp)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (rpp),hl
  inc de
  ld c,e
  ld b,d
  jp next
;
  defb 0xC1    ; ;
  defm ';'
  defw colon-4
semi:
  defw docol
  defw qcsp
  defw comp
  defw semis
  defw smudg
  defw lbrac
  defw semis
;
  defb 0x84   ;noop
  defm 'NOOP'
  defw semi-4
noop:
  defw docol
  defw semis
;
  defb 0x88   ;constant
  defm 'CONSTANT'
  defw noop-7
con:
  defw docol
  defw creat
  defw smudg
  defw comma
  defw pscod
docon:
  inc de
  ex de,hl
  ld e,(hl)
  inc hl
  ld d,(hl)
  push de
  jp next
;
  defb 0x88   ;variable
  defm 'VARIABLE'
  defw con-0x0B
var:
  defw docol
  defw con
  defw pscod
dovar:
  inc de
  push de
  jp next
;
  defb 0x84   ;user
  defm 'USER'
  defw var-0x0B
user:
  defw docol
  defw con
  defw pscod
douse:
  inc de
  ex de,hl
  ld e,(hl)
  ld d,0x00
  ld hl,(up)
  add hl,de
  jp hpush
;
  defb 0x81   ;0
  defm '0'
  defw user-7
zero:
  defw $+2   ;/
  ld hl,0    ;/
  jp hpush      ;/
;
  defb 0x81   ;1
  defm '1'
  defw zero-4
one:
  defw $+2   ;/
  ld hl,1    ;/
  jp hpush      ;/
;
  defb 0x81   ;2
  defm '2'
  defw one-4
two:
  defw $+2   ;/
  ld hl,2    ;/
  jp hpush      ;/
;
  defb 0x81   ;3
  defm '3'
  defw two-4
three:
  defw $+2   ;/
  ld hl,3    ;/
  jp hpush      ;/
;
  defb 0x82   ;bl
  defm 'BL'
  defw three-4
bl:
  defw docon
  defw 0x20
;
  defb 0x83   ;c/l
  defm 'C/L'
  defw bl-5
csll:
  defw docon
  defw 64
;
  defb 0x85   ;first
  defm 'FIRST'
  defw csll-6
first:
  defw docon
  defw 0   ;/ set by cld
;
  defb 0x85   ;limit
  defm 'LIMIT'
  defw first-8
limit:
  defw docon
  defw 0   ;/ set by cld
;
  defb 0x85   ;b/buf
  defm 'B/BUF'
  defw limit-8
bbuf:
  defw docon
  defw kbbuf
;
  defb 0x85   ;b/scr
  defm 'B/SCR'
  defw bbuf-8
bscr:
  defw docon
  defw 0x400/kbbuf
;
  defb 0x87   ;+origin
  defm '+ORIGIN'
  defw bscr-8
porig:
  defw docol
  defw lit
  defw origin
  defw plus
  defw semis
;
; user variables
;
  defb 0x82   ;s0
  defm 'S0'
  defw porig-0x0A
szero:
  defw douse
  defw 6
;
  defb 0x82   ;r0
  defm 'R0'
  defw szero-5
rzero:
  defw douse
  defw 8
;
  defb 0x83   ;tib
  defm 'TIB'
  defw rzero-5
tib:
  defw douse
  defb 0x0A
;
  defb 0x85   ;width
  defm 'WIDTH'
  defw tib-6
width:
  defw douse
  defb 0x0C
;
  defb 0x87   ;warning
  defm 'WARNING'
  defw width-8
warn:
  defw douse
  defb 0x0E
;
  defb 0x85   ;fence
  defm 'FENCE'
  defw warn-0x0A
fence:
  defw douse
  defb 0x10
;
  defb 0x82   ;dp
  defm 'DP'
  defw fence-8
dp:
  defw douse
  defb 0x12
;
  defb 0x88   ;voc-link
  defm 'VOC-LINK'
  defw dp-5
vocl:
  defw douse
  defw 0x14
;
  defb 0x83   ;blk
  defm 'BLK'
  defw vocl-0x0B
blk:
  defw douse
  defb 0x16
;
  defb 0x82   ;in
  defm 'IN'
  defw blk-6
inn:
  defw douse
  defb 0x18
;
  defb 0x83   ;out
  defm 'OUT'
  defw inn-5
outt:
  defw douse
  defb 0x1A
;
  defb 0x83   ;scr
  defm 'SCR'
  defw outt-6
scr:
  defw douse
  defb 0x1C
;
  defb 0x86   ;offset
  defm 'OFFSET'
  defw scr-6
ofset:
  defw douse
  defb 0x1E
;
  defb 0x87   ;context
  defm 'CONTEXT'
  defw ofset-9
cont:
  defw douse
  defb 0x20
;
  defb 0x87   ;current
  defm 'CURRENT'
  defw cont-0x0A
curr:
  defw douse
  defb 0x22
;
  defb 0x85   ;state
  defm 'STATE'
  defw curr-0x0A
state:
  defw douse
  defb 0x24
;
  defb 0x84   ;base
  defm 'BASE'
  defw state-8
base:
  defw douse
  defb 0x26
;
  defb 0x83   ;dpl
  defm 'DPL'
  defw base-7
dpl:
  defw douse
  defb 0x28
;
  defb 0x83   ;fld
  defm 'FLD'
  defw dpl-6
fld:
  defw douse
  defb 0x2A
;
  defb 0x83   ;csp
  defm 'CSP'
  defw fld-6
cspp:
  defw douse
  defb 0x2C
;
  defb 0x82   ;r#
  defm 'R#'
  defw cspp-6
rnum:
  defw douse
  defb 0x2E
;
  defb 0x83   ;hld
  defm 'HLD'
  defw rnum-5
hld:
  defw douse
  defw 0x30
;
; end of user variables
;
  defb 0x82   ;1+
  defm '1+'
  defw hld-6
onep:
  defw $+2   ;/
  pop hl    ;/
  inc hl    ;/
  jp hpush      ;/
;
  defb 0x82   ;2+
  defm '2+'
  defw onep-5
twop:
  defw $+2   ;/
  pop hl    ;/
  inc hl    ;/
  inc hl    ;/
  jp hpush      ;/
;
  defb 0x82   ;/ 1-
  defm '1-'    ;/
  defw twop-5    ;/
onemin:
  defw $+2   ;/
  pop hl    ;/
  dec hl    ;/
  jp hpush      ;/
;
  defb 0x82   ;/ 2-
  defm '2-'    ;/
  defw onemin-5  ;/
twomin:
  defw $+2   ;/
  pop hl    ;/
  dec hl    ;/
  dec hl    ;/
  jp hpush      ;/
;
  defb 0x82   ;/ 2*
  defm '2*'    ;/
  defw twomin-5  ;/
twosta:
  defw $+2   ;/
  pop hl    ;/
  add hl,hl   ;/ asl hl
  jp hpush      ;/
;
  defb 0x82   ;/ 2/
  defm '2/'    ;/
  defw twosta-5  ;/
twosla:
  defw $+2   ;/
  pop hl    ;/
  bit 7,h   ;/
  jr z,twosl1  ;/
  inc hl    ;/
twosl1:
  sra h   ;/
  rr l   ;/ asr hl
  jp hpush      ;/
;
  defb 0x84   ;here
  defm 'HERE'
  defw twosla-5
here:
  defw docol
  defw dp
  defw at
  defw semis
;
  defb 0x85   ;allot
  defm 'ALLOT'
  defw here-7
allot:
  defw docol
  defw dp
  defw pstor
  defw semis
;
  defb 0x81   ; ,
  defm ','
  defw allot-8
comma:
  defw docol
  defw here
  defw store
  defw two
  defw allot
  defw semis
;
  defb 0x82   ;c,
  defm 'C,'
  defw comma-4
ccomm:
  defw docol
  defw here
  defw cstor
  defw one
  defw allot
  defw semis
;
  defb 0x81   ;-
  defm '-'
  defw ccomm-5
subb:
  defw $+2
  pop de
  pop hl
  or a   ;/ reset carry
  sbc hl,de   ;/
  jp hpush
;
  defb 0x81   ;=
  defm '='
  defw subb-4
equal:
  defw $+2   ;/
  pop de    ;/
  pop hl    ;/
  xor a   ;/ reset carry
  sbc hl,de   ;/
  ld h,a   ;/
  ld l,a   ;/ ld hl,0x0000
  jr nz,exequ  ;/ false
  inc l   ;/ true
exequ:
  jp hpush      ;/
;
  defb 0x81   ;  <
  defm '<'
  defw equal-4
less:
  defw $+2
  pop de
  pop hl    ;  (hl) (de) <
  ld a,d
  xor h   ;  one of them negative?
  jp m,les1    ;  yes, determine which
  or a   ;/ clr carry
  sbc hl,de   ;/
les1:
  bit 7,h   ;/ (h) negative?
  ld hl,0
  jr z,exless  ;/ no, false
  inc l   ;/ true
exless:
  jp hpush
;
  defb 0x82   ;u<
  defm 'U<'
  defw less-4
uless:
  defw $+2   ;/
  pop de
  pop hl    ;/ (hl) (de) u<
  xor a   ;/
  sbc hl,de   ;/
  ld h,a   ;/
  ld l,a   ;/ ld hl,0x0000
  jr nc,exules ;/ false
  inc l   ;/ true
exules:
  jp hpush
;
  defb 0x81   ;>
  defm '>'
  defw uless-5
great:
  defw $+2
  pop hl    ;/
  pop de    ;/ (hl) (de) > = (de) (hl) <
  ld a,d
  xor h   ;  one of them negative?
  jp m,great1  ;  yes, determine which
  or a   ;/ clr carry
  sbc hl,de   ;/
great1:
  bit 7,h   ;/ (h) negative?
  ld hl,0    ;  (hl)<--false
  jr z,great2  ;/ no, false
  inc l   ;/ (hl)<--true
great2:
  jp hpush
;
  defb 0x83   ;rot
  defm 'ROT'
  defw great-4
rot:
  defw $+2
  pop de
  pop hl
  ex (sp),hl
  jp dpush
;
  defb 0x85   ;space
  defm 'SPACE'
  defw rot-6
space:
  defw docol
  defw bl
  defw emit
  defw semis
;
  defb 0x84   ;-dup
  defm '-DUP'
  defw space-8
ddup:
  defw $+2   ;/
  pop hl    ;/
  ld a,h   ;/
  or l   ;/ (hl)=0?
  jr z,exddup  ;/ yes, DON'T dup
  push hl    ;/
exddup:
  jp hpush
;
  defb 0x88   ;traverse
  defm 'TRAVERSE'
  defw ddup-7
trav:
  defw docol
  defw swap
trav1:
  defw over    ;begin
  defw plus
  defw lit
  defw 0x7F
  defw over
  defw cat
  defw less
  defw zbran   ;until
  defw trav1-$
  defw swap
  defw drop
  defw semis
;
  defb 0x86   ;latest
  defm 'LATEST'
  defw trav-0x0B
lates:
  defw docol
  defw curr
  defw at
  defw at
  defw semis
;
  defb 0x83   ;lfa
  defm 'LFA'
  defw lates-9
lfa:
  defw $+2   ;/
  pop hl    ;/ (hl)<--pfa
  dec hl    ;/
  dec hl    ;/
  dec hl    ;/
  dec hl    ;/ (hl)<--(hl)-4 = lfa
  jp hpush      ;/
;
  defb 0x83   ;cfa
  defm 'CFA'
  defw lfa-6
cfa:
  defw docol
  defw twomin    ;/
  defw semis
;
  defb 0x83   ;nfa
  defm 'NFA'
  defw cfa-6
nfa:
  defw docol
  defw lit
  defw 5
  defw subb
  defw lit
  defw -1
  defw trav
  defw semis
;
  defb 0x83   ;pfa
  defm 'PFA'
  defw nfa-6
pfa:
  defw docol
  defw one
  defw trav
  defw lit
  defw 5
  defw plus
  defw semis
;
  defb 0x84   ;!csp
  defm '!CSP'
  defw pfa-6
scsp:
  defw docol
  defw spat
  defw cspp
  defw store
  defw semis
;
  defb 0x86   ;?error
  defm '?ERROR'
  defw scsp-7
qerr:
  defw docol
  defw swap
  defw zbran   ;if
  defw qerr1-$
  defw error
  defw bran    ;else
  defw qerr2-$
qerr1:
  defw drop    ;endif
qerr2:
  defw semis
;
  defb 0x85   ;?comp
  defm '?COMP'
  defw qerr-9
qcomp:
  defw docol
  defw state
  defw at
  defw zequ
  defw lit
  defw 0x11
  defw qerr
  defw semis
;
  defb 0x85   ;?exec
  defm '?EXEC'
  defw qcomp-8
qexec:
  defw docol
  defw state
  defw at
  defw lit
  defw 0x12
  defw qerr
  defw semis
;
  defb 0x86   ;?pairs
  defm '?PAIRS'
  defw qexec-8
qpair:
  defw docol
  defw subb
  defw lit
  defw 0x13
  defw qerr
  defw semis
;
  defb 0x84   ;?csp
  defm '?CSP'
  defw qpair-9
qcsp:
  defw docol
  defw spat
  defw cspp
  defw at
  defw subb
  defw lit
  defw 0x14
  defw qerr
  defw semis
;
  defb 0x88   ;?loading
  defm '?LOADING'
  defw qcsp-7
qload:
  defw docol
  defw blk
  defw at
  defw zequ
  defw lit
  defw 0x16
  defw qerr
  defw semis
;
  defb 0x87   ;compile
  defm 'COMPILE'
  defw qload-0x0B
comp:
  defw docol
  defw qcomp
  defw fromr
  defw dup
  defw twop
  defw tor
  defw at
  defw comma
  defw semis
;
  defb 0xC1    ;[
  defm '['
  defw comp-0x0A
lbrac:
  defw docol
  defw zero
  defw state
  defw store
  defw semis
;
  defb 0x81   ;]
  defm ']'
  defw lbrac-4
rbrac:
  defw docol
  defw lit,0xC0
  defw state,store
  defw semis
;
  defb 0x86   ;smudge
  defm 'SMUDGE'
  defw rbrac-4
smudg:
  defw docol
  defw lates
  defw lit
  defw 0x20
  defw toggl
  defw semis
;
  defb 0x83   ;hex
  defm 'HEX'
  defw smudg-9
hex:
  defw docol
  defw lit
  defw 0x10
  defw base
  defw store
  defw semis
;
  defb 0x87   ;decimal
  defm 'DECIMAL'
  defw hex-6
decimal:
  defw docol
  defw lit
  defw 0x0A
  defw base
  defw store
  defw semis
;
  defb 0x87   ;(;code)
  defm '(;code)'
  defw decimal-0x0A
pscod:
  defw docol
  defw fromr
  defw lates
  defw pfa
  defw cfa
  defw store
  defw semis
;
  defb 0xC5    ; ;code
  defm ';CODE'
  defw pscod-0x0A
semic:
  defw docol
  defw qcsp
  defw comp
  defw pscod
  defw lbrac
semi1:
  defw noop    ;assembler
  defw semis
;
  defb 0x87   ;<builds
  defm '<BUILDS'
  defw semic-8
build:
  defw docol
  defw zero
  defw con
  defw semis
;
  defb 0x85   ;does>
  defm 'DOES>'
  defw build-0x0A
does:
  defw docol
  defw fromr
  defw lates
  defw pfa
  defw store
  defw pscod
dodoe:
  ld hl,(rpp)
  dec hl
  ld (hl),b
  dec hl
  ld (hl),c
  ld (rpp),hl
  inc de
  ex de,hl
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  jp hpush
;
  defb 0x85   ;count
  defm 'COUNT'
  defw does-8
count:
  defw docol
  defw dup
  defw onep
  defw swap
  defw cat
  defw semis
;
  defb 0x84   ;type
  defm 'TYPE'
  defw count-8
type:
  defw docol
  defw ddup
  defw zbran   ;if
  defw type1-$
  defw over
  defw plus
  defw swap
  defw xdo   ;do
type2:
  defw ido
  defw cat
  defw emit
  defw xloop   ;loop
  defw type2-$
  defw bran    ;else
  defw type3-$
type1:
  defw drop    ;endif
type3:
  defw semis
;
  defb 0x89   ;-trailing
  defm '-TRAILING'
  defw type-7
dtrai:
  defw docol
  defw dup
  defw zero
  defw xdo   ;do
dtra1:
  defw tdup    ;/
  defw plus
  defw onemin    ;/
  defw cat
  defw bl
  defw subb
  defw zbran   ;if
  defw dtra2-$
  defw leave
  defw bran    ;else
  defw dtra3-$
dtra2:
  defw onemin    ;/
dtra3:
  defw xloop   ;loop
  defw dtra1-$
  defw semis
;
  defb 0x84   ;(.")
  defm '(.")'
  defw dtrai-0x0C
pdotq:
  defw docol
  defw rfetch
  defw count
  defw dup
  defw onep
  defw fromr
  defw plus
  defw tor
  defw type
  defw semis
;
  defb 0xC2    ;."
  defm '."'
  defw pdotq-7
dotq:
  defw docol
  defw lit
  defw 0x22
  defw state
  defw at
  defw zbran   ;if
  defw dotq1-$
  defw comp
  defw pdotq
  defw word
  defw here
  defw cat
  defw onep
  defw allot
  defw bran    ;else
  defw dotq2-$
dotq1:
  defw word
  defw here
  defw count
  defw type    ;endif
dotq2:
  defw semis
;
  defb 0x86   ;expect
  defm 'EXPECT'
  defw dotq-5
expec:
  defw docol
  defw over
  defw plus
  defw over
  defw xdo   ;do
expe1:
  defw key
  defw dup
  defw lit
  defw 0x0E
  defw porig
  defw at
  defw equal
  defw zbran   ;if
  defw expe2-$
  defw drop
  defw dup
  defw ido
  defw equal
  defw dup
  defw fromr
  defw twomin    ;/
  defw plus
  defw tor
  defw zbran   ;if
  defw expe6-$
  defw lit
  defw bell
  defw bran    ;else
  defw expe7-$
expe6:
  defw lit
  defw bsout   ;endif
expe7:
  defw bran    ;else
  defw expe3-$
expe2:
  defw dup
  defw lit
  defw acr   ;/
  defw equal
  defw zbran   ;if
  defw expe4-$
  defw leave
  defw drop
  defw bl
  defw zero
  defw bran    ;else
  defw expe5-$
expe4:
  defw dup   ;endif
expe5:
  defw ido
  defw cstor
  defw zero
  defw ido
  defw onep
  defw store   ;endif
expe3:
  defw emit
  defw xloop   ;loop
  defw expe1-$
  defw drop
  defw semis
;
  defb 0x85   ;query
  defm 'QUERY'
  defw expec-9
query:
  defw docol
  defw tib
  defw at
  defw lit
  defw 0x50
  defw expec
  defw zero
  defw inn
  defw store
  defw semis
;
  defb 0xC1    ;null
  defb 0x80
  defw query-8
null:
  defw docol
  defw blk
  defw at
  defw zbran   ;if
  defw null1-$
  defw one
  defw blk
  defw pstor
  defw zero
  defw inn
  defw store
  defw blk
  defw at
  defw bscr
  defw onemin    ;/
  defw andd
  defw zequ
  defw zbran   ;if
  defw null2-$
  defw qexec
  defw fromr
  defw drop    ;endif
null2:
  defw bran    ;else
  defw null3-$
null1:
  defw fromr
  defw drop    ;endif
null3:
  defw semis
;
  defb 0x84   ;fill
  defm 'FILL'
  defw null-4
fill:
  defw $+2
  exx ;/ save ip
  pop de    ;/ (e)<--byte
  pop bc    ;  (bc)<--quantity
  pop hl    ;/ (hl)<--addr
fill1:
  ld a,b
  or c   ;  qty=0?
  jr z,fill2   ;  yes
  ld (hl),e    ;/ ((hl))<--byte
  inc hl    ;  inc pointer
  dec bc    ;  dec counter
  jp fill1   ;/
fill2:
  exx ;/ restore ip
  jp next
;
  defb 0x85   ;erase
  defm 'ERASE'
  defw fill-7
erasee:
  defw docol
  defw zero
  defw fill
  defw semis
;
  defb 0x86   ;blanks
  defm 'BLANKS'
  defw erasee-8
blank:
  defw docol
  defw bl
  defw fill
  defw semis
;
  defb 0x84   ;hold
  defm 'HOLD'
  defw blank-9
hold:
  defw docol
  defw lit
  defw -1
  defw hld
  defw pstor
  defw hld
  defw at
  defw cstor
  defw semis
;
  defb 0x83   ;pad
  defm 'PAD'
  defw hold-7
pad:
  defw docol
  defw here
  defw lit
  defw 0x44
  defw plus
  defw semis
;
  defb 0x84   ;word
  defm 'WORD'
  defw pad-6
word:
  defw docol
  defw blk
  defw at
  defw zbran   ;if
  defw word1-$
  defw blk
  defw at
  defw block
  defw bran    ;else
  defw word2-$
word1:
  defw tib
  defw at    ;endif
word2:
  defw inn
  defw at
  defw plus
  defw swap
  defw encl
  defw here
  defw lit
  defw 0x22
  defw blank
  defw inn
  defw pstor
  defw over
  defw subb
  defw tor
  defw rfetch
  defw here
  defw cstor
  defw plus
  defw here
  defw onep
  defw fromr
  defw cmove
  defw semis
;
  defb 0x88   ;(number)
  defm '(number)'
  defw word-7
pnumb:
  defw docol
pnum1:
  defw onep    ;begin
  defw dup
  defw tor
  defw cat
  defw base
  defw at
  defw digit
  defw zbran   ;while
  defw pnum2-$
  defw swap
  defw base
  defw at
  defw ustar
  defw drop
  defw rot
  defw base
  defw at
  defw ustar
  defw dplus
  defw dpl
  defw at
  defw onep
  defw zbran   ;if
  defw pnum3-$
  defw one
  defw dpl
  defw pstor   ;endif
pnum3:
  defw fromr
  defw bran    ;repeat
  defw pnum1-$
pnum2:
  defw fromr
  defw semis
;
  defb 0x86   ;number
  defm 'NUMBER'
  defw pnumb-0x0B
numb:
  defw docol
  defw zero
  defw zero
  defw rot
  defw dup
  defw onep
  defw cat
  defw lit
  defw 0x2D
  defw equal
  defw dup
  defw tor
  defw plus
  defw lit
  defw -1
numb1:
  defw dpl   ;begin
  defw store
  defw pnumb
  defw dup
  defw cat
  defw bl
  defw subb
  defw zbran   ;while
  defw numb2-$
  defw dup
  defw cat
  defw lit
  defw 0x2E
  defw subb
  defw zero
  defw qerr
  defw zero
  defw bran    ;repeat
  defw numb1-$
numb2:
  defw drop
  defw fromr
  defw zbran   ;if
  defw numb3-$
  defw dminu   ;endif
numb3:
  defw semis
;
  defb 0x85   ;-find (0-3) success
  defm '-FIND'   ;      (0-1) failure
  defw numb-9
dfind:
  defw docol
  defw bl
  defw word
  defw here
  defw cont
  defw at
  defw at
  defw pfind
  defw dup
  defw zequ
  defw zbran   ;if
  defw dfin1-$
  defw drop
  defw here
  defw lates
  defw pfind   ;endif
dfin1:
  defw semis
;
  defb 0x87   ;(abort)
  defm '(abort)'
  defw dfind-8
pabor:
  defw docol
  defw abort
  defw semis
;
  defb 0x85   ;error
  defm 'ERROR'
  defw pabor-0x0A
error:
  defw docol
  defw warn
  defw at
  defw zless
  defw zbran   ;if
  defw erro1-$
  defw pabor   ;endif
erro1:
  defw here
  defw count
  defw type
  defw pdotq
  defb 2
  db '? '
  defw mess
  defw spsto
; change from fig model
; defw  inn,at,blk,at
  defw blk,at
  defw ddup
  defw zbran,erro2-$ ;if
  defw inn,at
  defw swap    ;endif
erro2:
  defw quit
;
  defb 0x83   ;ID.
  defm 'ID.'
  defw error-8
iddot:
  defw docol
  defw pad
  defw lit
  defw 0x20
  defw blank   ;/
  defw dup
  defw pfa
  defw lfa
  defw over
  defw subb
  defw dup   ;/ change frm model
  defw tor   ;/ to suppress bit 7
  defw pad
  defw swap
  defw cmove
  defw pad
  defw fromr   ;/ for terminals
  defw pad   ;/ with an 8 bit
  defw plus    ;/ ascci character set.
  defw onemin    ;/
  defw dup   ;/
  defw at    ;/
  defw lit   ;/
  defw 0x7F   ;/
  defw andd    ;/
  defw swap    ;/
  defw store   ;/
  defw count
  defw lit
  defw 0x1F   ;  width
  defw andd
  defw type
  defw space
  defw semis
;
  defb 0x86   ;create
  defm 'CREATE'
  defw iddot-6
creat:
  defw docol
  defw dfind
  defw zbran   ;if
  defw crea1-$
  defw drop
  defw nfa
  defw iddot
  defw lit
  defw 4
  defw mess
  defw space   ;endif
crea1:
  defw here
  defw dup
  defw cat
  defw width
  defw at
  defw min
  defw onep
  defw allot
  defw dup
  defw lit
  defw 0xA0
  defw toggl
  defw here
  defw onemin
  defw lit
  defw 0x80
  defw toggl
  defw lates
  defw comma
  defw curr
  defw at
  defw store
  defw here
  defw twop
  defw comma
  defw semis
;
  defb 0xC9    ;[compile]
  defm '[compile]'
  defw creat-9
bcomp:
  defw docol
  defw dfind
  defw zequ
  defw zero
  defw qerr
  defw drop
  defw cfa
  defw comma
  defw semis
;
  defb 0xC7    ;literal
  defm 'LITERAL'
  defw bcomp-0x0C
liter:
  defw docol
  defw state
  defw at
  defw zbran   ;if
  defw lite1-$
  defw comp
  defw lit
  defw comma   ;endif
lite1:
  defw semis
;
  defb 0xC8    ;dliteral
  defm 'DLITERAL'
  defw liter-0x0A
dlite:
  defw docol
  defw state
  defw at
  defw zbran   ;if
  defw dlit1-$
  defw swap
  defw liter
  defw liter   ;endif
dlit1:
  defw semis
;
  defb 0x86   ;?stack
  defm '?STACK'
  defw dlite-0x0B
qstac:
  defw docol
  defw spat
  defw szero
  defw at
  defw swap
  defw uless
  defw one
  defw qerr
  defw spat
  defw here
  defw lit
  defw 0x80
  defw plus
  defw uless
  defw lit
  defw 7
  defw qerr
  defw semis
;
  defb 0x89   ;interpret
  defm 'INTERPRET'
  defw qstac-9
inter:
  defw docol
inte1:
  defw dfind   ;begin
  defw zbran   ;if
  defw inte2-$
  defw state
  defw at
  defw less
  defw zbran   ;if
  defw inte3-$
  defw cfa
  defw comma
  defw bran    ;else
  defw inte4-$
inte3:
  defw cfa
  defw exec    ;endif
inte4:
  defw qstac
  defw bran    ;else
  defw inte5-$
inte2:
  defw here
  defw numb
  defw dpl
  defw at
  defw onep
  defw zbran   ;if
  defw inte6-$
  defw dlite
  defw bran    ;else
  defw inte7-$
inte6:
  defw drop
  defw liter   ;endif
inte7:
  defw qstac   ;endif
inte5:
  defw bran    ;again
  defw inte1-$
;
  defb 0x89   ;immediate
  defm 'IMMEDIATE'
  defw inter-0x0C
immed:
  defw docol
  defw lates
  defw lit
  defw 0x40
  defw toggl
  defw semis
;
  defb 0x8A   ;vocabulary
  defm 'VOCABULARY'
  defw immed-0x0C
vocab:
  defw docol
  defw build
  defw lit
  defw 0A081H
  defw comma
  defw curr
  defw at
  defw cfa
  defw comma
  defw here
  defw vocl
  defw at
  defw comma
  defw vocl
  defw store
  defw does
dovoc:
  defw twop
  defw cont
  defw store
  defw semis
;
  defb 0xC5    ;forth
  defm 'FORTH'
  defw vocab-0x0D
forth:
  defw dodoe
  defw dovoc
  defw 0A081H
  defw task-7    ;cold start value ONLY.
;       changed each time a def is appended
;       to the forth vocabulary
  defw 0   ;end of vocabulary list
;
  defb 0x8B   ;definitions
  defm 'DEFINITIONS'
  defw forth-8
defin:
  defw docol
  defw cont
  defw at
  defw curr
  defw store
  defw semis
;
  defb 0xC1    ;(
  defm '('
  defw defin-0x0E
paren:
  defw docol
  defw lit
  defw 0x29
  defw word
  defw semis
;
  defb 0x84   ;quit
  defm 'QUIT'
  defw paren-4
quit:
  defw docol
  defw zero
  defw blk
  defw store
  defw lbrac
quit1:
  defw rpsto   ;begin
  defw cr
  defw query
  defw inter
  defw state
  defw at
  defw zequ
  defw zbran   ;if
  defw quit2-$
  defw pdotq
  defb 2
  db 'ok'    ;endif
quit2:
  defw bran    ;again
  defw quit1-$
;
  defb 0x85   ;abort
  defm 'ABORT'
  defw quit-7
abort:
  defw docol
  defw spsto
  defw decimal
  defw qstac
  defw cr
  defw dotcpu
  defw pdotq
  defb 0x0E   ;count of CHRs to follow
  db 'fig-forth '
  defb figrel+0x30,adot,figrev+0x30,usrver
  defw forth
  defw defin
  defw quit
;
wrm:
  ld bc,wrm1
  jp next
wrm1:
  defw warm
;
  defb 0x84   ;warm
  defm 'WARM'
  defw abort-8
warm:
  defw docol
  defw mtbuf
  defw abort
;
cld:
  ld hl,(bdoss+1)  ;/
  ld l,0   ;/ (hl)<--fbase
  ld (limit+2),hl  ;/ set limit
  ld de,bufsiz ;/ (de)<--total disc buffer size
  or a   ;/ clr carry
  sbc hl,de   ;/ (hl)<--addr. of 1st disc buffer
  ld (first+2),hl  ;/ set first
  ld (use+2),hl  ;/ set use
  ld (prev+2),hl ;/ set prev
  ld (buf1),hl ;/
  ld de,us   ;/ (de)<--user variable space
  sbc hl,de   ;/ (hl)<--initr0
  ld (upinit),hl ;/
  ld (r0init),hl ;/
  ld (up),hl   ;/
  ld (rpp),hl  ;/
  ld de,rts    ;/ (de)<--return stack & terminal buffer space
  sbc hl,de   ;/ (hl)<--inits0
  ld (s0init),hl ;/
  ld (tibini),hl ;/
  ld sp,hl   ;/
  ld bc,cld1
  jp next
;
cld1:
  defw cold
;
  defb 0x84   ;cold
  defm 'COLD'
  defw warm-7
cold:
  defw docol
  defw mtbuf
  defw one,recadr  ;AvdH
  defw store
  defw lit,buf1
  defw at    ;/
  defw use,store
  defw lit,buf1
  defw at    ;/
  defw prev,store
  defw drzer
  defw zero    ;/
  defw lit,eprint
  defw cstor   ;/
;
  defw lit
  defw origin+0x12
  defw lit
  defw up
  defw at
  defw lit
  defw 6
  defw plus
  defw lit
  defw 0x10
  defw cmove
  defw lit
  defw origin+0x0C
  defw at
  defw lit
  defw forth+6
  defw store
  defw fcb   ;/a
  defw lit,opnfil  ;/a open mass storage
  defw bdos    ;/a
  defw lit,0xFF  ;/a
  defw equal   ;/a file present?
  defw zbran,cld2-$  ;/a
  defw zero    ;/a
  defw warn,store  ;/a
  defw cr,pdotq  ;/a
  defb 7   ;/a
  db 'No file' ;/a
cld2:
  defw abort
;
  defb 0x84   ;s->d
  defm 'S->D'
  defw cold-7
stod:
  defw $+2
  pop de
  ld hl,0
  bit 7,d   ;/ # negative?
  jr z,stod1   ;  no
  dec hl    ;  yes, extend sign
stod1:
  jp dpush   ;  ( n1--d1L d1H)
;
  defb 0x82   ;+-
  defm '+-'
  defw stod-7
pm:
  defw docol
  defw zless
  defw zbran   ;if
  defw pm1-$
  defw minus   ;endif
pm1:
  defw semis
;
  defb 0x83   ;d+-
  defm 'D+-'
  defw pm-5
dpm:
  defw docol
  defw zless
  defw zbran   ;if
  defw dpm1-$
  defw dminu   ;endif
dpm1:
  defw semis
;
  defb 0x83   ;abs
  defm 'ABS'
  defw dpm-6
ABS_:
  defw docol
  defw dup
  defw pm
  defw semis
;
  defb 0x84   ;dabs
  defm 'DABS'
  defw ABS_-6
dabs:
  defw docol
  defw dup
  defw dpm
  defw semis
;
  defb 0x83   ;min
  defm 'MIN'
  defw dabs-7
min:
  defw docol,tdup
  defw great
  defw zbran   ;if
  defw min1-$
  defw swap    ;endif
min1:
  defw drop
  defw semis
;
  defb 0x83   ;max
  defm 'MAX'
  defw min-6
max:
  defw docol
  defw tdup
  defw less
  defw zbran   ;if
  defw max1-$
  defw swap    ;endif
max1:
  defw drop
  defw semis
;
  defb 0x82   ;m*
  defm 'M*'
  defw max-6
mstar:
  defw docol,tdup
  defw xorr
  defw tor
  defw ABS_
  defw swap
  defw ABS_
  defw ustar
  defw fromr
  defw dpm
  defw semis
;
  defb 0x82   ;m/
  defm 'M/'
  defw mstar-5
mslas:
  defw docol
  defw over
  defw tor
  defw tor
  defw dabs
  defw rfetch
  defw ABS_
  defw uslas
  defw fromr
  defw rfetch
  defw xorr
  defw pm
  defw swap
  defw fromr
  defw pm
  defw swap
  defw semis
;
  defb 0x81   ;  *
  defm '*'
  defw mslas-5
star:
  defw $+2
  exx ;/ save ip
  pop hl
  pop de
  ld a,l   ;/
  ld c,h   ;/
  ld b,0x10   ;/
  ld hl,0    ;/
star1:
  srl c   ;/
  rra ;/ srl ca  (mpcator)
  jr nc,star2  ;/ lsb (ca)=0?
  add hl,de   ;/ no, add mpcant to hl
star2:
  sla e   ;/
  rl d   ;/ sla de  (mpcant 2 *)
  djnz star1   ;/ do all 16 bits
  push hl    ;/ (s1)<--product
  exx ;/ restore ip
  jp next
;
  defb 0x84   ;  /mod
  defm '/MOD'
  defw star-4
slmod:
  defw $+2
  pop de    ;/ divisor
  pop hl    ;/ dividend
  push bc    ;/ save ip
  xor a   ;/ reset negate flag
  ex af,AF'    ;/ alt set
  ld a,d   ;/
  or e   ;/ div by 0?
  jr nz,slmod1 ;/
  ld hl,-1   ;/ yes
  ld d,h   ;/
  ld e,l   ;/ quot & rem <-- -1
  jr slmod7    ;/ exit
slmod1:
  bit 7,d   ;/ divisor negative?
  jr z,slmod2  ;/
  ld a,e   ;/ yes
  cpl ;/
  ld e,a   ;/
  ld a,d   ;/
  cpl ;/
  ld d,a   ;/
  inc de    ;/ (de)<--(de)'s 2's complement
  ex af,AF'    ;/ std set
  scf ;/ set negate flag
  ex af,AF'    ;/ alt set
slmod2:
  bit 7,h   ;/ dividend negative?
  jr z,slmod3  ;/
  ld a,l   ;/ yes
  cpl ;/
  ld l,a   ;/
  ld a,h   ;/
  cpl ;/
  ld h,a   ;/
  inc hl    ;/ (hl)<--(hl)'s 2's complement
  ex af,AF'    ;/ std set
  ccf ;/ negate flag
  inc a   ;/ dividend sign flag
  ex af,AF'    ;/ alt set
slmod3:
  ld a,l   ;/
  ld c,h   ;/ (ca)<--dividend
  ld hl,0    ;/ prime remainder
  ld b,0x10   ;/ loop counter
slmod4:
  rla ;/
  rl c   ;/ rl ca
  adc hl,hl   ;/ (hl)<--(hl) 2 * carry +
  sbc hl,de   ;/ underflow?
  jr nc,slmod5 ;/ no
  add hl,de   ;/ yes, restore remainder
slmod5:
  ccf ;/
  djnz slmod4    ;/ do all 16 bits
  rla ;/
  rl c   ;/ rl ca
  ld e,a   ;/
  ld d,c   ;/ (de)<--quotient
  ex af,AF'    ;/ std set
  jr z,slmod6  ;/ dividend positive
  ld a,l   ;/
  cpl ;/
  ld l,a   ;/
  ld a,h   ;/
  cpl ;/
  ld h,a   ;/
  inc hl    ;/ rem gets DIVIDEND'S sign
slmod6:
  jr nc,slmod7 ;/ quotient positive
  ld a,e   ;/
  cpl ;/
  ld e,a   ;/
  ld a,d   ;/
  cpl ;/
  ld d,a   ;/
  inc de    ;/ negative quotient
slmod7:
  pop bc    ;/ restore ip
  ex de,hl   ;/ (s2)<--remainder
  jp dpush   ;/ (s1)<--quotient
;
  defb 0x81   ; /
  defm '/'
  defw slmod-7
slash:
  defw $+2
  pop de    ;/ divisor
  pop hl    ;/ dividend
  push bc    ;/ save ip
  xor a   ;/ reset NEG. flag
  ex af,AF'    ;/ alt set
  ld a,d   ;/
  or e   ;/ div by 0?
  jr nz,slash1 ;/
  ld hl,-1   ;/ yes, set quotient to -1
  jr slash6    ;/ exit
slash1:
  bit 7,d   ;/ divisor negative?
  jr z,slash2  ;/
  ld a,e   ;/ yes
  cpl ;/
  ld e,a   ;/
  ld a,d   ;/
  cpl ;/
  ld d,a   ;/
  inc de    ;/ (de)<--(de)'s 2's complement
  ex af,AF'    ;/ std set
  scf ;/ set NEG. flag
  ex af,AF'    ;/ alt set
slash2:
  bit 7,h   ;/ dividend negative?
  jr z,slash3  ;/
  ld a,l   ;/ yes
  cpl ;/
  ld l,a   ;/
  ld a,h   ;/
  cpl ;/
  ld h,a   ;/
  inc hl    ;/ (hl)<--(hl)'s 2's complement
  ex af,AF'    ;/ std set
  ccf ;/ NEG. flag
  ex af,AF'    ;/ alt set
slash3:
  ld a,l   ;/
  ld c,h   ;/ (ca)<--dividend
  ld hl,0    ;/
  ld b,0x10   ;/ loop counter
slash4:
  rla ;/
  rl c   ;/ rl ca
  adc hl,hl   ;/ (hl)<--(hl) 2 * carry +
  sbc hl,de   ;/ underflow?
  jr nc,slash5 ;/ no
  add hl,de   ;/ yes, restore remainder
slash5:
  ccf ;/
  djnz slash4    ;/ do all 16 bits
  rla ;/
  rl c   ;/ rl ca
  ld l,a   ;/
  ld h,c   ;/ (hl)<--quotient
  ex af,AF'    ;/ std set
  jr nc,slash6 ;/ positive quotient
  ld a,l   ;/
  cpl ;/
  ld l,a   ;/
  ld a,h   ;/
  cpl ;/
  ld h,a   ;/
  inc hl    ;/ negative quotient
slash6:
  pop bc    ;/ restore ip
  jp hpush
;
  defb 0x83   ; mod
  defm 'MOD'
  defw slash-4
modd:
  defw docol
  defw slmod
  defw drop
  defw semis
;
  defb 0x85   ; */mod
  defm '*/MOD'
  defw modd-6
ssmod:
  defw docol
  defw tor
  defw mstar
  defw fromr
  defw mslas
  defw semis
;
  defb 0x82   ; */
  defm '*/'
  defw ssmod-8
ssla:
  defw docol
  defw ssmod
  defw swap
  defw drop
  defw semis
;
  defb 0x85   ; m/mod
  defm 'M/MOD'
  defw ssla-5
msmod:
  defw docol
  defw tor
  defw zero
  defw rfetch
  defw uslas
  defw fromr
  defw swap
  defw tor
  defw uslas
  defw fromr
  defw semis
;
; Block moved down 2 pages
;
  defb 0x86   ; (line)
  defm '(line)'
  defw msmod-8
pline:
  defw docol
  defw tor
  defw lit
  defw 0x40
  defw bbuf
  defw ssmod
  defw fromr
  defw bscr
  defw star
  defw plus
  defw block
  defw plus
  defw lit
  defw 0x40
  defw semis
;
  defb 0x85   ; .LINE
  defm '.LINE'
  defw pline-9
dline:
  defw docol
  defw pline
  defw dtrai
  defw type
  defw semis
;
  defb 0x87   ;message
  defm 'MESSAGE'
  defw dline-8
mess:
  defw docol
  defw warn
  defw at
  defw zbran   ;if
  defw mess1-$
  defw ddup
  defw zbran   ;if
  defw mess2-$
  defw lit
  defw 4   ;1st message screen
  defw ofset
  defw at
  defw bscr
  defw slash
  defw subb
  defw dline
  defw space   ;endif
mess2:
  defw bran    ;else
  defw mess3-$
mess1:
  defw pdotq
  defb 6
  db 'MSG # '
  defw dot   ;endif
mess3:
  defw semis
;
  defb 0x82   ;p@
  defm 'P@'
  defw mess-0x0A
ptat:
  defw $+2
  exx ;d save registers
  pop bc    ;d (bc)<--port#
  in l,(c)   ;d (l)<--data byte
  ld h,0
  push hl
  exx ;d restore registers
  jp next
;
  defb 0x82   ;p!
  defm 'P!'
  defw ptat-5
ptsto:
  defw $+2
  exx ;d save registers
  pop bc    ;d (c)<--port#
  pop hl    ;d (l)<--data byte
  out (c),l
  exx ;d restore registers
  jp next
;
; cp/m disc interface
;
; Last update:
;
; 881228 - EXTEND's r/w address now initialized with blanks
; 860120 - EXTEND's r/w address now here, was Osborne video ram
; 850511 - saved BC' in 'BDOS'
; 850227 - saved index regs. in 'BDOS'
; 840812 - added extend
; 840731 - installed bdos calls
;
;
; cp/m bdos calls used (as per Albert van der Horst, hcch)
;
; r/w reads or writes a sector in the file specified when invoking
; z80 fig-forth (a>z80forth d:filename.ext), using the default FCB.
; More than one disc may be accessed by temporary use of a user de-
; fined FCB.
;
;
;
deffcb  equ 0x005C   ;default fcb
;
; cp/m functions
;
opnfil  equ 0x0F   ;open file
clsfil  equ 0x10   ;close file
setdma  equ 0x1A   ;set dma address
wrtrnd  equ 0x22   ;write random
;
;
; forth variables & constants used in disc interface
;
  defb 0x83   ;fcb (current fcb address)
  defm 'FCB'
  defw ptsto-5
fcb:
  defw docon,deffcb
;
  defb 0x84   ;rec# (returns address of random rec.#)
  defm 'REC#'
  defw fcb-6
recadr:
  defw docol,fcb
  defw lit,0x21
  defw plus
  defw semis
;
  defb 0x83   ;use
  defm 'USE'
  defw recadr-7
use:
  defw dovar,0   ;/ initialised by cld
;
  defb 0x84   ;prev
  defm 'PREV'
  defw use-6
prev:
  defw dovar,0   ;/ initialised by cld
;
  defb 0x85   ;#buff
  defm '#BUFF'
  defw prev-0x07
nobuf:
  defw docon,nbuf
;
  defb 0x8A   ;disk-error
  defm 'DISK-ERROR'
  defw nobuf-0x08
dskerr:
  defw dovar,0
;
; disc interface high level routines
;
  defb 0x84   ;+buf
  defm '+BUF'
  defw dskerr-0x0D
pbuf:
  defw docol
  defw lit,co
  defw plus,dup
  defw limit,equal
  defw zbran,pbuf1-$
  defw drop,first
pbuf1:
  defw dup,prev
  defw at,subb
  defw semis
;
  defb 0x86   ;update
  defm 'UPDATE'
  defw pbuf-0x07
updat:
  defw docol,prev
  defw at,at
  defw lit,0x8000
  defw orr
  defw prev,at
  defw store,semis
;
  defb 0x8D   ;empty-buffers
  defm 'EMPTY-BUFFERS'
  defw updat-9
mtbuf:
  defw docol,first
  defw limit,over
  defw subb,erasee
  defw semis
;
  defb 0x83   ;dr0
  defm 'DR0'
  defw mtbuf-0x10
drzer:
  defw docol
  defw zero
  defw ofset,store
  defw semis
;
  defb 0x83   ;dr1
  defm 'DR1'
  defw drzer-6
drone:
  defw docol
  defw lit,1600  ;Osborne dd
dron2:
  defw ofset,store
  defw semis
;
  defb 0x86   ;buffer
  defm 'BUFFER'
  defw drone-6
buffe:
  defw docol,use
  defw at,dup
  defw tor
buff1:
  defw pbuf    ;won't work if single buffer
  defw zbran,buff1-$
  defw use,store
  defw rfetch,at
  defw zless
  defw zbran,buff2-$
  defw rfetch,twop
  defw rfetch,at
  defw lit,0x7FFF
  defw andd,zero
  defw rslw
buff2:
  defw rfetch,store
  defw rfetch,prev
  defw store,fromr
  defw twop,semis
;
  defb 0x85   ;block
  defm 'BLOCK'
  defw buffe-9
block:
  defw docol,ofset
  defw at,plus
  defw tor,prev
  defw at,dup
  defw at,rfetch
  defw subb
  defw dup,plus
  defw zbran,bloc1-$
bloc2:
  defw pbuf,zequ
  defw zbran,bloc3-$
  defw drop,rfetch
  defw buffe,dup
  defw rfetch,one
  defw rslw
  defw twomin    ;/
bloc3:
  defw dup,at
  defw rfetch,subb
  defw dup,plus
  defw zequ
  defw zbran,bloc2-$
  defw dup,prev
  defw store
bloc1:
  defw fromr,drop
  defw twop,semis
;
  defb 0x84   ;bdos  (cp/m function call)
  defm 'BDOS'
  defw block-8
bdos:
  defw $+2
  exx ;save ip
  pop bc    ;(c) <-- (s1)lb = cp/m function code
  pop de    ;(de) <-- (s2)  = parameter
  push ix    ;/
  push iy    ;/
  exx
  push bc    ;/ save ip
  exx
  call bdoss   ;return value in a
  exx
  pop bc    ;restore ip
  exx
  pop iy    ;/
  pop ix    ;/
  exx ;restore ip
  ld l,a
  ld h,0x00
  jp hpush      ;(s1) <-- (hl) = returned value
;
  defb 0x83   ;r/w
  defm 'R/W'
  defw bdos-0x07
rslw:
  defw docol
  defw tor   ;store r/w flag
  defw recadr,store
  defw zero,recadr ;set record #
  defw twop,cstor
  defw lit,setdma
  defw bdos,drop ;set dma address
  defw lit,wrtrnd
  defw fromr,subb  ;select read or write
  defw fcb,swap
  defw bdos    ;do it
  defw dskerr,store  ;store return code
  defw semis
;
  defb 0x85   ;flush
  defm 'FLUSH'
  defw rslw-6
flush:
  defw docol
  defw nobuf,onep
  defw zero,xdo
flus1:
  defw zero,buffe
  defw drop
  defw xloop,flus1-$
  defw semis
;
;
  defb 86h     ;/ extend
  defm 'EXTEND'
  defw flush-08h
extend:
  defw docol
  defw here      ;/ fill with b/buf blanks
  defw bbuf
  defw blank
  defw lit
  defw 0008h
  defw star
  defw zero
extnd1:
  defw onep      ; begin
  defw here      ;/ was lit,f000h (Osborne video ram)
  defw over
  defw one
  defw rslw
  defw dskerr
  defw at
  defw zbran
  defw extnd1-$    ; until
  defw swap
  defw over
  defw plus
  defw swap
  defw xdo     ; do
extnd2:
  defw here      ;/ was lit,f000h (Osborne video ram)
  defw ido
  defw zero
  defw rslw
  defw xloop
  defw extnd2-$    ; loop
  defw fcb
  defw lit
  defw clsfil
  defw bdos      ; close file
  defw drop      ; discard return code
  defw fcb
  defw lit
  defw opnfil
  defw bdos      ; & re-open
  defw drop      ; discard return code
  defw semis
;
;
  defb 0x84   ;load
  defm 'LOAD'
  defw extend-0x09
load:
  defw docol,blk
  defw at,tor
  defw inn,at
  defw tor,zero
  defw inn,store
  defw bscr,star
  defw blk,store ;blk <-- scr * b/scr
  defw inter   ;interpret from other screen
  defw fromr,inn
  defw store
  defw fromr,blk
  defw store,semis
;
  defb 0xC3    ;-->
  defm '-->'
  defw load-7
arrow:
  defw docol,qload
  defw zero
  defw inn,store
  defw bscr,blk
  defw at,over
  defw modd,subb
  defw blk,pstor
  defw semis
;

; cp/m console & printer interface
;
; Last update:
;
; 850511 - Saved BC' prior to cp/m calls
; 841010 - Saved ix & iy prior to cp/m calls
; 840909 - Converted all bios calls to bdos calls for compatibility
;          with cp/m 3.0
;
;
;
lstout  equ 0x05   ;printer output
dconio  equ 0x06   ;direct console i/o
;
rubout  equ 0x7F
inpreq  equ 0xFF    ;dconio input request
;
eprint:
  defb 0   ;printer flag
        ;0=disabled, 1=enabled
;
sysent:
  push bc
  push de
  push hl
  push ix
  push iy
  exx
  push bc    ;save ip (if used as such)
  exx
  call bdoss   ;perform function (c)
  exx
  pop bc    ;restore ip
  exx
  pop iy
  pop ix
  pop hl
  pop de
  pop bc
  ret
;
cstat:
  push bc
  ld c,dconio  ;direct console i/o
  ld e,inpreq  ;input request
  call sysent    ;any chr typed?
  pop bc    ;if yes, (a)<--char
  ret ;else    (a)<--0x00 (ignore chr)
;
cin:
  push bc
  ld c,dconio  ;direct console i/o
  ld e,inpreq  ;request input
cinlp:
  call sysent    ;(a)<--chr (or 0 if nothing typed)
  or a
  jr z,cinlp   ;wait for chr to be typed
  cp rubout
  jr nz,cin1
  ld a,bsout   ;convert rub to ^h
cin1:
  res 7,a   ;(msb)<--0
  pop bc
  ret
;
cout:
  push bc
  push de    ;save (e) = chr
  ld c,dconio  ;direct console output
  call sysent    ;send (e) to con:
  pop de
  pop bc
  ret
;
pout:
  push bc
  ld c,lstout
  call sysent    ;send (e) to lst:
  pop bc
  ret
;
cpout:
  call cout    ;send (e) to console
  ld a,(eprint)
  or a   ;if (eprint) <> 0
  call nz,pout   ;send (e) to lst:
  ret
;
; forth to cp/m serial i/o interface
;
pqter:
  call cstat
  ld hl,0
  or a   ;chr typed?
  jr z,pqte1   ;no
  inc l   ;yes, (s1)<--true
pqte1:
  jp hpush
;
pkey:
  call cin   ;read chr from console
  cp dle   ;^p?
  ld e,a
  jr nz,pkey1  ;no
  ld hl,eprint
  ld e,abl   ;(e)<--blank
  ld a,(hl)
  xor 0x01   ;toggle (eprint) lsb
  ld (hl),a
pkey1:
  ld l,e
  ld h,0
  jp hpush      ;(s1)lb<--chr
;
pemit:
  defw $+2   ;(emit) orphan
  pop de    ;(e)<--(s1)lb = chr
  ld a,e
  cp bsout
  jr nz,pemit1
  call cout    ;backspace
  ld e,abl   ;blank
  call cout    ;erase chr on con:
  ld e,bsout   ;backspace
pemit1:
  call cpout   ;send chr to con:
        ;and lst: if (eprint)=0x01
  jp next
;
pcr:
  ld e,acr
  call cpout   ;output cr
  ld e,lf
  call cpout   ;and lf
  jp next
;
  defb 0xC1    ; ' (tick)
  defb 0xA7
  defw arrow-6
tick:
  defw docol
  defw dfind
  defw zequ
  defw zero
  defw qerr
  defw drop
  defw liter
  defw semis
;
  defb 0x86   ;forget
  defm 'FORGET'
  defw tick-4
forg:
  defw docol
  defw curr
  defw at
  defw cont
  defw at
  defw subb
  defw lit
  defw 0x18
  defw qerr
  defw tick
  defw dup
  defw fence
  defw at
  defw uless   ;/ forget >8000h nw o.k.
  defw lit
  defw 0x15
  defw qerr
  defw dup
  defw nfa
  defw dp
  defw store
  defw lfa
  defw at
  defw cont
  defw at
  defw store
  defw semis
;
  defb 0x84   ;back
  defm 'BACK'
  defw forg-9
back:
  defw docol
  defw here
  defw subb
  defw comma
  defw semis
;
  defb 0xC5    ;begin
  defm 'BEGIN'
  defw back-7
begin:
  defw docol
  defw qcomp
  defw here
  defw one
  defw semis
;
  defb 0xC5    ;endif
  defm 'ENDIF'
  defw begin-8
endiff:
  defw docol
  defw qcomp
  defw two
  defw qpair
  defw here
  defw over
  defw subb
  defw swap
  defw store
  defw semis
;
  defb 0xC4    ;then
  defm 'THEN'
  defw endiff-8
then:
  defw docol
  defw endiff
  defw semis
;
  defb 0xC2    ;do
  defm 'DO'
  defw then-7
do:
  defw docol
  defw comp
  defw xdo
  defw here
  defw three
  defw semis
;
  defb 0xC4    ;loop
  defm 'LOOP'
  defw do-5
loop:
  defw docol
  defw three
  defw qpair
  defw comp
  defw xloop
  defw back
  defw semis
;
  defb 0xC5    ;+loop
  defm '+LOOP'
  defw loop-7
ploop:
  defw docol
  defw three
  defw qpair
  defw comp
  defw xploo
  defw back
  defw semis
;
  defb 0xC5    ;until
  defm 'UNTIL'
  defw ploop-8
until:
  defw docol
  defw one
  defw qpair
  defw comp
  defw zbran
  defw back
  defw semis
;
  defb 0xC3    ;end
  defm 'END'
  defw until-8
endd:
  defw docol
  defw until
  defw semis
;
  defb 0xC5    ;again
  defm 'AGAIN'
  defw endd-6
again:
  defw docol
  defw one
  defw qpair
  defw comp
  defw bran
  defw back
  defw semis
;
  defb 0xC6    ;repeat
  defm 'REPEAT'
  defw again-8
repea:
  defw docol
  defw tor
  defw tor
  defw again
  defw fromr
  defw fromr
  defw twomin    ;/
  defw endiff
  defw semis
;
  defb 0xC2    ;if
  defm 'IF'
  defw repea-9
iff:
  defw docol
  defw comp
  defw zbran
  defw here
  defw zero
  defw comma
  defw two
  defw semis
;
  defb 0xC4    ;else
  defm 'ELSE'
  defw iff-5
elsee:
  defw docol
  defw two
  defw qpair
  defw comp
  defw bran
  defw here
  defw zero
  defw comma
  defw swap
  defw two
  defw endiff
  defw two
  defw semis
;
  defb 0xC5    ;while
  defm 'WHILE'
  defw elsee-7
while:
  defw docol
  defw iff
  defw twop
  defw semis
;
  defb 0x86   ;spaces
  defm 'SPACES'
  defw while-8
spacs:
  defw docol
  defw zero
  defw max
  defw ddup
  defw zbran   ;if
  defw spax1-$
  defw zero
  defw xdo   ;do
spax2:
  defw space
  defw xloop   ;loop endif
  defw spax2-$
spax1:
  defw semis
;
  defb 0x82   ;<#
  defm '<#'
  defw spacs-9
bdigs:
  defw docol
  defw pad
  defw hld
  defw store
  defw semis
;
  defb 0x82   ;#>
  defm '#>'
  defw bdigs-5
edigs:
  defw docol
  defw drop
  defw drop
  defw hld
  defw at
  defw pad
  defw over
  defw subb
  defw semis
;
  defb 0x84   ;sign
  defm 'SIGN'
  defw edigs-5
sign:
  defw docol
  defw rot
  defw zless
  defw zbran   ;if
  defw sign1-$
  defw lit
  defw 0x2D
  defw hold    ;endif
sign1:
  defw semis
;
  defb 0x81   ;#
  defm '#'
  defw sign-7
dig:
  defw docol
  defw base
  defw at
  defw msmod
  defw rot
  defw lit
  defw 9
  defw over
  defw less
  defw zbran   ;if
  defw dig1-$
  defw lit
  defw 7
  defw plus    ;endif
dig1:
  defw lit
  defw 0x30
  defw plus
  defw hold
  defw semis
;
  defb 0x82   ;#s
  defm '#S'
  defw dig-4
digs:
  defw docol
digs1:
  defw dig   ;begin
  defw tdup    ;/
  defw orr
  defw zequ
  defw zbran   ;until
  defw digs1-$
  defw semis
;
  defb 0x83   ;D.R
  defm 'D.R'
  defw digs-5
ddotr:
  defw docol
  defw tor
  defw swap
  defw over
  defw dabs
  defw bdigs
  defw digs
  defw sign
  defw edigs
  defw fromr
  defw over
  defw subb
  defw spacs
  defw type
  defw semis
;
  defb 0x82   ;.R
  defm '.R'
  defw ddotr-6
dotr:
  defw docol
  defw tor
  defw stod
  defw fromr
  defw ddotr
  defw semis
;
  defb 0x82   ;D.
  defm 'D.'
  defw dotr-5
ddot:
  defw docol
  defw zero
  defw ddotr
  defw space
  defw semis
;
  defb 0x81   ; .
  defm '.'
  defw ddot-5
dot:
  defw docol
  defw stod
  defw ddot
  defw semis
;
  defb 0x81   ;?
  defm '?'
  defw dot-4
ques:
  defw docol
  defw at
  defw dot
  defw semis
;
  defb 0x82   ;U.
  defm 'U.'
  defw ques-4
udot:
  defw docol
  defw zero
  defw ddot
  defw semis
;
  defb 0x85   ;vlist
  defm 'VLIST'
  defw udot-5
vlist:
  defw docol
  defw lit
  defw 0x80
  defw outt
  defw store
  defw cont
  defw at
  defw at
vlis1:
  defw outt    ;begin
  defw at
  defw csll
  defw great
  defw zbran   ;if
  defw vlis2-$
  defw cr
  defw zero
  defw outt
  defw store   ;endif
vlis2:
  defw dup
  defw iddot
  defw space
  defw space
  defw pfa
  defw lfa
  defw at
  defw dup
  defw zequ
  defw qterm
  defw orr
  defw zbran   ;until
  defw vlis1-$
  defw drop
  defw semis
;
  defb 0x83   ;bye
  defm 'BYE'
  defw vlist-8
bye:
  defw docol   ;/a
  defw flush   ;/a
  defw fcb,lit   ;/e
  defw 0x10,bdos  ;/e close file
  defw drop    ;/e discard directory code
  defw zero,zero ;/a
  defw bdos    ;/a return to cp/m
  defw semis   ;/a won't get this far, just for pretty
;
  defb 0x84   ;list
  defm 'LIST'
  defw bye-6
list:
  defw docol,decimal
  defw cr,dup
  defw scr,store
  defw pdotq
  defb 6
  db 'SCR # '
  defw dot
  defw lit,0x10
  defw zero,xdo
list1:
  defw cr,ido
  defw three   ;/ was lit,3
  defw dotr,space
  defw ido,scr
  defw at,dline
  defw qterm
  defw zbran,list2-$ ;if
  defw leave
list2:
  defw xloop,list1-$ ;endif
  defw cr,semis
;
  defb 0x85   ;index
  defm 'INDEX'
  defw list-7
index:
  defw docol
  defw lit,ff
  defw emit,cr
  defw onep,swap
  defw xdo
inde1:
  defw cr,ido
  defw three   ;/ was lit,3
  defw dotr,space
  defw zero,ido
  defw dline,qterm
  defw zbran,inde2-$ ;if
  defw leave   ;endif
inde2:
  defw xloop,inde1-$
  defw semis
;
  defb 0x85   ;triad
  defm 'TRIAD'
  defw index-8
triad:
  defw docol
  defw lit,ff
  defw emit
  defw three   ;/ was lit,3
  defw slash
  defw three   ;/ was lit,3
  defw star
  defw three   ;/ was lit,3
  defw over,plus
  defw swap,xdo
tria1:
  defw cr,ido
  defw list
  defw qterm
  defw zbran,tria2-$ ;if
  defw leave
tria2:
  defw xloop,tria1-$ ;endif
  defw cr
  defw lit,15
  defw mess,cr
  defw semis
;
  defb 0x84   ;.CPU
  defm '.CPU'
  defw triad-8
dotcpu:
  defw docol
  defw base,at
  defw lit,36
  defw base,store
  defw lit,0x22
  defw porig,tat
  defw ddot
  defw base,store
  defw semis
;
  defb 0x84   ;task
  defm 'TASK'
  defw dotcpu-7
task:
  defw docol
  defw semis
;
initdp:
  defw 0
;
  end
